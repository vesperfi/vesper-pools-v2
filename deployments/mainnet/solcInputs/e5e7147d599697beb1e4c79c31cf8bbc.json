{
  "language": "Solidity",
  "sources": {
    "contracts/Controller.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"./Owned.sol\";\nimport \"./interfaces/vesper/IVesperPool.sol\";\nimport \"./interfaces/vesper/IStrategy.sol\";\nimport \"./interfaces/vesper/IPoolRewards.sol\";\nimport \"../sol-address-list/contracts/interfaces/IAddressList.sol\";\nimport \"../sol-address-list/contracts/interfaces/IAddressListFactory.sol\";\n\ncontract Controller is Owned {\n    using SafeMath for uint256;\n\n    // Pool specific params\n    mapping(address => uint256) public withdrawFee;\n    mapping(address => uint256) public interestFee;\n    mapping(address => address) public feeCollector;\n    mapping(address => uint256) public rebalanceFriction;\n    mapping(address => address) public strategy;\n    mapping(address => address) public poolRewards;\n    uint16 public aaveReferralCode;\n    address public founderVault;\n    uint256 public founderFee = 5e16;\n    address public treasuryPool;\n    address public uniswapRouter = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;\n    IAddressList public immutable pools;\n\n    constructor() public {\n        IAddressListFactory addressFactory =\n            IAddressListFactory(0xD57b41649f822C51a73C44Ba0B3da4A880aF0029);\n        pools = IAddressList(addressFactory.createList());\n    }\n\n    modifier validPool(address pool) {\n        require(pools.contains(pool), \"Not a valid pool\");\n        _;\n    }\n\n    /**\n     * @dev Add new pool in vesper system\n     * @param _pool Address of new pool\n     */\n    function addPool(address _pool) external onlyOwner {\n        require(_pool != address(0), \"invalid-pool\");\n        IERC20 pool = IERC20(_pool);\n        require(pool.totalSupply() == 0, \"Zero supply required\");\n        pools.add(_pool);\n    }\n\n    /**\n     * @dev Remove pool from vesper system\n     * @param _pool Address of pool to be removed\n     */\n    function removePool(address _pool) external onlyOwner {\n        IERC20 pool = IERC20(_pool);\n        require(pool.totalSupply() == 0, \"Zero supply required\");\n        pools.remove(_pool);\n    }\n\n    /**\n     * @dev Execute transaction in given target contract\n     * @param target Address of target contract\n     * @param value Ether amount to transfer\n     * @param signature Signature of function in target contract\n     * @param data Encoded data for function call\n     */\n    function executeTransaction(\n        address target,\n        uint256 value,\n        string memory signature,\n        bytes memory data\n    ) external payable onlyOwner returns (bytes memory) {\n        return _executeTransaction(target, value, signature, data);\n    }\n\n    /// @dev Execute multiple transactions.\n    function executeTransactions(\n        address[] memory targets,\n        uint256[] memory values,\n        string[] memory signatures,\n        bytes[] memory calldatas\n    ) external payable onlyOwner {\n        require(targets.length != 0, \"Must provide actions\");\n        require(\n            targets.length == values.length &&\n                targets.length == signatures.length &&\n                targets.length == calldatas.length,\n            \"Transaction data mismatch\"\n        );\n\n        for (uint256 i = 0; i < targets.length; i++) {\n            _executeTransaction(targets[i], values[i], signatures[i], calldatas[i]);\n        }\n    }\n\n    function updateAaveReferralCode(uint16 referralCode) external onlyOwner {\n        aaveReferralCode = referralCode;\n    }\n\n    function updateFeeCollector(address _pool, address _collector)\n        external\n        onlyOwner\n        validPool(_pool)\n    {\n        require(_collector != address(0), \"invalid-collector\");\n        require(feeCollector[_pool] != _collector, \"same-collector\");\n        feeCollector[_pool] = _collector;\n    }\n\n    function updateFounderVault(address _founderVault) external onlyOwner {\n        founderVault = _founderVault;\n    }\n\n    function updateFounderFee(uint256 _founderFee) external onlyOwner {\n        require(founderFee != _founderFee, \"same-founderFee\");\n        require(_founderFee <= 1e18, \"founderFee-above-100%\");\n        founderFee = _founderFee;\n    }\n\n    function updateInterestFee(address _pool, uint256 _interestFee)\n        external\n        onlyOwner\n        validPool(_pool)\n    {\n        require(_interestFee <= 1e18, \"Fee limit reached\");\n        require(feeCollector[_pool] != address(0), \"FeeCollector not set\");\n        interestFee[_pool] = _interestFee;\n    }\n\n    function updateStrategy(address _pool, address _newStrategy)\n        external\n        onlyOwner\n        validPool(_pool)\n    {\n        require(_newStrategy != address(0), \"invalid-strategy-address\");\n        address currentStrategy = strategy[_pool];\n        require(currentStrategy != _newStrategy, \"same-pool-strategy\");\n        require(IStrategy(_newStrategy).pool() == _pool, \"wrong-pool\");\n        IVesperPool vpool = IVesperPool(_pool);\n        if (currentStrategy != address(0)) {\n            require(IStrategy(currentStrategy).isUpgradable(), \"strategy-is-not-upgradable\");\n            vpool.resetApproval();\n        }\n        strategy[_pool] = _newStrategy;\n        vpool.approveToken();\n    }\n\n    function updateRebalanceFriction(address _pool, uint256 _f)\n        external\n        onlyOwner\n        validPool(_pool)\n    {\n        require(rebalanceFriction[_pool] != _f, \"same-friction\");\n        rebalanceFriction[_pool] = _f;\n    }\n\n    function updatePoolRewards(address _pool, address _poolRewards)\n        external\n        onlyOwner\n        validPool(_pool)\n    {\n        require(IPoolRewards(_poolRewards).pool() == _pool, \"wrong-pool\");\n        poolRewards[_pool] = _poolRewards;\n    }\n\n    function updateTreasuryPool(address _pool) external onlyOwner validPool(_pool) {\n        treasuryPool = _pool;\n    }\n\n    function updateUniswapRouter(address _uniswapRouter) external onlyOwner {\n        uniswapRouter = _uniswapRouter;\n    }\n\n    function updateWithdrawFee(address _pool, uint256 _newWithdrawFee)\n        external\n        onlyOwner\n        validPool(_pool)\n    {\n        require(_newWithdrawFee <= 1e18, \"withdraw-fee-limit-reached\");\n        require(withdrawFee[_pool] != _newWithdrawFee, \"same-withdraw-fee\");\n        require(feeCollector[_pool] != address(0), \"FeeCollector-not-set\");\n        withdrawFee[_pool] = _newWithdrawFee;\n    }\n\n    function isPool(address _pool) external view returns (bool) {\n        return pools.contains(_pool);\n    }\n\n    function _executeTransaction(\n        address target,\n        uint256 value,\n        string memory signature,\n        bytes memory data\n    ) internal onlyOwner returns (bytes memory) {\n        bytes memory callData;\n        if (bytes(signature).length == 0) {\n            callData = data;\n        } else {\n            callData = abi.encodePacked(bytes4(keccak256(bytes(signature))), data);\n        }\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returnData) = target.call{value: value}(callData);\n        require(success, \"Transaction execution reverted.\");\n        return returnData;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        uint256 c = a + b;\n        if (c < a) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b > a) return (false, 0);\n        return (true, a - b);\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) return (true, 0);\n        uint256 c = a * b;\n        if (c / a != b) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a / b);\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a % b);\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) return 0;\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: division by zero\");\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a % b;\n    }\n}\n"
    },
    "contracts/Owned.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/GSN/Context.sol\";\n\n// Requried one small change in openzeppelin version of ownable, so imported\n// source code here. Notice line 26 for change.\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\ncontract Ownable is Context {\n    /**\n     * @dev Changed _owner from 'private' to 'internal'\n     */\n    address internal _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() internal {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n\n/**\n * @dev Contract module extends Ownable and provide a way for safe transfer ownership.\n * Proposed owner has to call acceptOwnership in order to complete ownership trasnfer.\n */\ncontract Owned is Ownable {\n    address private _proposedOwner;\n\n    /**\n     * @dev Initiate transfer ownership of the contract to a new account (`proposedOwner`).\n     * Can only be called by the current owner. Current owner will still be owner until\n     * proposed owner accept ownership.\n     * @param proposedOwner proposed owner address\n     */\n    function transferOwnership(address proposedOwner) public override onlyOwner {\n        //solhint-disable-next-line reason-string\n        require(proposedOwner != address(0), \"Proposed owner is the zero address\");\n        _proposedOwner = proposedOwner;\n    }\n\n    /// @dev Allows proposed owner to accept ownership of the contract.\n    function acceptOwnership() public {\n        require(msg.sender == _proposedOwner, \"Caller is not the proposed owner\");\n        emit OwnershipTransferred(_owner, _proposedOwner);\n        _owner = _proposedOwner;\n        _proposedOwner = address(0);\n    }\n\n    function renounceOwnership() public override onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n        _proposedOwner = address(0);\n    }\n}\n"
    },
    "contracts/interfaces/vesper/IVesperPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IVesperPool is IERC20 {\n    function approveToken() external;\n\n    function deposit() external payable;\n\n    function deposit(uint256) external;\n\n    function multiTransfer(uint256[] memory) external returns (bool);\n\n    function permit(\n        address,\n        address,\n        uint256,\n        uint256,\n        uint8,\n        bytes32,\n        bytes32\n    ) external;\n\n    function rebalance() external;\n\n    function resetApproval() external;\n\n    function sweepErc20(address) external;\n\n    function withdraw(uint256) external;\n\n    function withdrawETH(uint256) external;\n\n    function withdrawByStrategy(uint256) external;\n\n    function feeCollector() external view returns (address);\n\n    function getPricePerShare() external view returns (uint256);\n\n    function token() external view returns (address);\n\n    function tokensHere() external view returns (uint256);\n\n    function totalValue() external view returns (uint256);\n\n    function withdrawFee() external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/vesper/IStrategy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\ninterface IStrategy {\n    function rebalance() external;\n\n    function deposit(uint256 amount) external;\n\n    function beforeWithdraw() external;\n\n    function withdraw(uint256 amount) external;\n\n    function withdrawAll() external;\n\n    function isUpgradable() external view returns (bool);\n\n    function isReservedToken(address _token) external view returns (bool);\n\n    function token() external view returns (address);\n\n    function pool() external view returns (address);\n\n    function totalLocked() external view returns (uint256);\n\n    //Lifecycle functions\n    function pause() external;\n\n    function unpause() external;\n}\n"
    },
    "contracts/interfaces/vesper/IPoolRewards.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\ninterface IPoolRewards {\n    function notifyRewardAmount(uint256) external;\n\n    function claimReward(address) external;\n\n    function updateReward(address) external;\n\n    function rewardForDuration() external view returns (uint256);\n\n    function claimable(address) external view returns (uint256);\n\n    function pool() external view returns (address);\n\n    function lastTimeRewardApplicable() external view returns (uint256);\n\n    function rewardPerToken() external view returns (uint256);\n}\n"
    },
    "sol-address-list/contracts/interfaces/IAddressList.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.6;\n\ninterface IAddressList {\n    event AddressUpdated(address indexed a, address indexed sender);\n    event AddressRemoved(address indexed a, address indexed sender);\n\n    function add(address a) external returns (bool);\n\n    function addValue(address a, uint256 v) external returns (bool);\n\n    function addMulti(address[] calldata addrs) external returns (uint256);\n\n    function addValueMulti(address[] calldata addrs, uint256[] calldata values) external returns (uint256);\n\n    function remove(address a) external returns (bool);\n\n    function removeMulti(address[] calldata addrs) external returns (uint256);\n\n    function get(address a) external view returns (uint256);\n\n    function contains(address a) external view returns (bool);\n\n    function at(uint256 index) external view returns (address, uint256);\n\n    function length() external view returns (uint256);\n}\n"
    },
    "sol-address-list/contracts/interfaces/IAddressListFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.6;\n\ninterface IAddressListFactory {\n    event ListCreated(address indexed _sender, address indexed _newList);\n\n    function ours(address a) external view returns (bool);\n\n    function listCount() external view returns (uint256);\n\n    function listAt(uint256 idx) external view returns (address);\n\n    function createList() external returns (address listaddr);\n}\n"
    },
    "@openzeppelin/contracts/GSN/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../utils/Context.sol\";\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"
    },
    "contracts/strategies/VSPStrategy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"../Pausable.sol\";\nimport \"../interfaces/vesper/IController.sol\";\nimport \"../interfaces/vesper/IVesperPool.sol\";\nimport \"../interfaces/bloq/ISwapManager.sol\";\nimport \"../../sol-address-list/contracts/interfaces/IAddressListExt.sol\";\nimport \"../../sol-address-list/contracts/interfaces/IAddressListFactory.sol\";\n\ncontract VSPStrategy is Pausable {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    uint256 public lastRebalanceBlock;\n    IController public immutable controller;\n    IVesperPool public immutable vvsp;\n    IAddressListExt public immutable keepers;\n    ISwapManager public swapManager = ISwapManager(0xe382d9f2394A359B01006faa8A1864b8a60d2710);\n    address internal constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n    uint256 public nextPoolIdx;\n    address[] public pools;\n    uint256[] public liquidationLimit;\n    string public constant NAME = \"Strategy-VSP\";\n    string public constant VERSION = \"2.0.3\";\n\n    event UpdatedSwapManager(address indexed previousSwapManager, address indexed newSwapManager);\n\n    constructor(address _controller, address _vvsp) public {\n        vvsp = IVesperPool(_vvsp);\n        controller = IController(_controller);\n        IAddressListFactory factory =\n            IAddressListFactory(0xD57b41649f822C51a73C44Ba0B3da4A880aF0029);\n        IAddressListExt _keepers = IAddressListExt(factory.createList());\n        _keepers.grantRole(keccak256(\"LIST_ADMIN\"), _controller);\n        keepers = _keepers;\n    }\n\n    modifier onlyKeeper() {\n        require(keepers.contains(_msgSender()), \"caller-is-not-keeper\");\n        _;\n    }\n\n    modifier onlyController() {\n        require(_msgSender() == address(controller), \"Caller is not the controller\");\n        _;\n    }\n\n    function pause() external onlyController {\n        _pause();\n    }\n\n    function unpause() external onlyController {\n        _unpause();\n    }\n\n    /**\n     * @notice Update swap manager address\n     * @param _swapManager swap manager address\n     */\n    function updateSwapManager(address _swapManager) external onlyController {\n        require(_swapManager != address(0), \"sm-address-is-zero\");\n        require(_swapManager != address(swapManager), \"sm-is-same\");\n        emit UpdatedSwapManager(address(swapManager), _swapManager);\n        swapManager = ISwapManager(_swapManager);\n    }\n\n    function updateLiquidationQueue(address[] calldata _pools, uint256[] calldata _limit)\n        external\n        onlyController\n    {\n        for (uint256 i = 0; i < _pools.length; i++) {\n            require(controller.isPool(_pools[i]), \"Not a valid pool\");\n            require(_limit[i] != 0, \"Limit cannot be zero\");\n        }\n        pools = _pools;\n        liquidationLimit = _limit;\n        nextPoolIdx = 0;\n    }\n\n    function isUpgradable() external view returns (bool) {\n        return IERC20(vvsp.token()).balanceOf(address(this)) == 0;\n    }\n\n    function pool() external view returns (address) {\n        return address(vvsp);\n    }\n\n    /**\n        withdraw Vtoken from vvsp => Deposit vpool => withdraw collateral => swap in uni for VSP => transfer vsp to vvsp pool\n        VETH => ETH => VSP\n     */\n    function rebalance() external whenNotPaused onlyKeeper {\n        require(\n            block.number - lastRebalanceBlock >= controller.rebalanceFriction(address(vvsp)),\n            \"Can not rebalance\"\n        );\n        lastRebalanceBlock = block.number;\n\n        if (nextPoolIdx == pools.length) {\n            nextPoolIdx = 0;\n        }\n\n        IVesperPool _poolToken = IVesperPool(pools[nextPoolIdx]);\n        uint256 _balance = _poolToken.balanceOf(address(vvsp));\n        if (_balance != 0 && address(_poolToken) != address(vvsp)) {\n            if (_balance > liquidationLimit[nextPoolIdx]) {\n                _balance = liquidationLimit[nextPoolIdx];\n            }\n            _rebalanceEarned(_poolToken, _balance);\n        }\n        nextPoolIdx++;\n    }\n\n    /// @dev sweep given token to vsp pool\n    function sweepErc20(address _fromToken) external {\n        uint256 amount = IERC20(_fromToken).balanceOf(address(this));\n        IERC20(_fromToken).safeTransfer(address(vvsp), amount);\n    }\n\n    function _rebalanceEarned(IVesperPool _poolToken, uint256 _amt) internal {\n        IERC20(address(_poolToken)).safeTransferFrom(address(vvsp), address(this), _amt);\n        _poolToken.withdrawByStrategy(_amt);\n        IERC20 from = IERC20(_poolToken.token());\n        IERC20 vsp = IERC20(vvsp.token());\n        (address[] memory path, uint256 amountOut, uint256 rIdx) =\n            swapManager.bestOutputFixedInput(\n                address(from),\n                address(vsp),\n                from.balanceOf(address(this))\n            );\n        if (amountOut != 0) {\n            from.safeApprove(address(swapManager.ROUTERS(rIdx)), 0);\n            from.safeApprove(address(swapManager.ROUTERS(rIdx)), from.balanceOf(address(this)));\n            swapManager.ROUTERS(rIdx).swapExactTokensForTokens(\n                from.balanceOf(address(this)),\n                1,\n                path,\n                address(this),\n                now + 30\n            );\n            vsp.safeTransfer(address(vvsp), vsp.balanceOf(address(this)));\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"../../math/SafeMath.sol\";\nimport \"../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        // solhint-disable-next-line max-line-length\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) { // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "contracts/Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/GSN/Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n */\ncontract Pausable is Context {\n    event Paused(address account);\n    event Shutdown(address account);\n    event Unpaused(address account);\n    event Open(address account);\n\n    bool public paused;\n    bool public stopEverything;\n\n    modifier whenNotPaused() {\n        require(!paused, \"Pausable: paused\");\n        _;\n    }\n    modifier whenPaused() {\n        require(paused, \"Pausable: not paused\");\n        _;\n    }\n\n    modifier whenNotShutdown() {\n        require(!stopEverything, \"Pausable: shutdown\");\n        _;\n    }\n\n    modifier whenShutdown() {\n        require(stopEverything, \"Pausable: not shutdown\");\n        _;\n    }\n\n    /// @dev Pause contract operations, if contract is not paused.\n    function _pause() internal virtual whenNotPaused {\n        paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /// @dev Unpause contract operations, allow only if contract is paused and not shutdown.\n    function _unpause() internal virtual whenPaused whenNotShutdown {\n        paused = false;\n        emit Unpaused(_msgSender());\n    }\n\n    /// @dev Shutdown contract operations, if not already shutdown.\n    function _shutdown() internal virtual whenNotShutdown {\n        stopEverything = true;\n        paused = true;\n        emit Shutdown(_msgSender());\n    }\n\n    /// @dev Open contract operations, if contract is in shutdown state\n    function _open() internal virtual whenShutdown {\n        stopEverything = false;\n        emit Open(_msgSender());\n    }\n}\n"
    },
    "contracts/interfaces/vesper/IController.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\ninterface IController {\n    function aaveReferralCode() external view returns (uint16);\n\n    function feeCollector(address) external view returns (address);\n\n    function founderFee() external view returns (uint256);\n\n    function founderVault() external view returns (address);\n\n    function interestFee(address) external view returns (uint256);\n\n    function isPool(address) external view returns (bool);\n\n    function pools() external view returns (address);\n\n    function strategy(address) external view returns (address);\n\n    function rebalanceFriction(address) external view returns (uint256);\n\n    function poolRewards(address) external view returns (address);\n\n    function treasuryPool() external view returns (address);\n\n    function uniswapRouter() external view returns (address);\n\n    function withdrawFee(address) external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/bloq/ISwapManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"../uniswap/IUniswapV2Router02.sol\";\n\n/* solhint-disable func-name-mixedcase */\n\ninterface ISwapManager {\n    event OracleCreated(address indexed _sender, address indexed _newOracle, uint256 _period);\n\n    function N_DEX() external view returns (uint256);\n\n    function ROUTERS(uint256 i) external view returns (IUniswapV2Router02);\n\n    function bestOutputFixedInput(\n        address _from,\n        address _to,\n        uint256 _amountIn\n    )\n        external\n        view\n        returns (\n            address[] memory path,\n            uint256 amountOut,\n            uint256 rIdx\n        );\n\n    function bestPathFixedInput(\n        address _from,\n        address _to,\n        uint256 _amountIn,\n        uint256 _i\n    ) external view returns (address[] memory path, uint256 amountOut);\n\n    function bestInputFixedOutput(\n        address _from,\n        address _to,\n        uint256 _amountOut\n    )\n        external\n        view\n        returns (\n            address[] memory path,\n            uint256 amountIn,\n            uint256 rIdx\n        );\n\n    function bestPathFixedOutput(\n        address _from,\n        address _to,\n        uint256 _amountOut,\n        uint256 _i\n    ) external view returns (address[] memory path, uint256 amountIn);\n\n    function safeGetAmountsOut(\n        uint256 _amountIn,\n        address[] memory _path,\n        uint256 _i\n    ) external view returns (uint256[] memory result);\n\n    function unsafeGetAmountsOut(\n        uint256 _amountIn,\n        address[] memory _path,\n        uint256 _i\n    ) external view returns (uint256[] memory result);\n\n    function safeGetAmountsIn(\n        uint256 _amountOut,\n        address[] memory _path,\n        uint256 _i\n    ) external view returns (uint256[] memory result);\n\n    function unsafeGetAmountsIn(\n        uint256 _amountOut,\n        address[] memory _path,\n        uint256 _i\n    ) external view returns (uint256[] memory result);\n\n    function comparePathsFixedInput(\n        address[] memory pathA,\n        address[] memory pathB,\n        uint256 _amountIn,\n        uint256 _i\n    ) external view returns (address[] memory path, uint256 amountOut);\n\n    function comparePathsFixedOutput(\n        address[] memory pathA,\n        address[] memory pathB,\n        uint256 _amountOut,\n        uint256 _i\n    ) external view returns (address[] memory path, uint256 amountIn);\n\n    function ours(address a) external view returns (bool);\n\n    function oracleCount() external view returns (uint256);\n\n    function oracleAt(uint256 idx) external view returns (address);\n\n    function getOracle(\n        address _tokenA,\n        address _tokenB,\n        uint256 _period,\n        uint256 _i\n    ) external view returns (address);\n\n    function createOrUpdateOracle(\n        address _tokenA,\n        address _tokenB,\n        uint256 _period,\n        uint256 _i\n    ) external returns (address oracleAddr);\n\n    function consultForFree(\n        address _from,\n        address _to,\n        uint256 _amountIn,\n        uint256 _period,\n        uint256 _i\n    ) external view returns (uint256 amountOut, uint256 lastUpdatedAt);\n\n    /// get the data we want and pay the gas to update\n    function consult(\n        address _from,\n        address _to,\n        uint256 _amountIn,\n        uint256 _period,\n        uint256 _i\n    )\n        external\n        returns (\n            uint256 amountOut,\n            uint256 lastUpdatedAt,\n            bool updated\n        );\n\n    function updateOracles() external returns (uint256 updated, uint256 expected);\n\n    function updateOracles(address[] memory _oracleAddrs)\n        external\n        returns (uint256 updated, uint256 expected);\n}\n"
    },
    "sol-address-list/contracts/interfaces/IAddressListExt.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.6;\n\nimport \"./IAddressList.sol\";\n\ninterface IAddressListExt is IAddressList {\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    function getRoleMemberCount(bytes32 role) external view returns (uint256);\n\n    function getRoleMember(bytes32 role, uint256 index) external view returns (address);\n\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    function grantRole(bytes32 role, address account) external;\n\n    function revokeRole(bytes32 role, address account) external;\n\n    function renounceRole(bytes32 role, address account) external;\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.2 <0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "contracts/interfaces/uniswap/IUniswapV2Router02.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"./IUniswapV2Router01.sol\";\n\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external;\n\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external payable;\n\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external;\n}\n"
    },
    "contracts/interfaces/uniswap/IUniswapV2Router01.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\ninterface IUniswapV2Router01 {\n    function factory() external pure returns (address);\n\n    function swapExactTokensForTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapTokensForExactTokens(\n        uint256 amountOut,\n        uint256 amountInMax,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapExactETHForTokens(\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external payable returns (uint256[] memory amounts);\n\n    function swapTokensForExactETH(\n        uint256 amountOut,\n        uint256 amountInMax,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapExactTokensForETH(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapETHForExactTokens(\n        uint256 amountOut,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external payable returns (uint256[] memory amounts);\n\n    function quote(\n        uint256 amountA,\n        uint256 reserveA,\n        uint256 reserveB\n    ) external pure returns (uint256 amountB);\n\n    function getAmountOut(\n        uint256 amountIn,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) external pure returns (uint256 amountOut);\n\n    function getAmountIn(\n        uint256 amountOut,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) external pure returns (uint256 amountIn);\n\n    function getAmountsOut(uint256 amountIn, address[] calldata path)\n        external\n        view\n        returns (uint256[] memory amounts);\n\n    function getAmountsIn(uint256 amountOut, address[] calldata path)\n        external\n        view\n        returns (uint256[] memory amounts);\n}\n"
    },
    "contracts/strategies/VSPAuctionStrategy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"../Pausable.sol\";\nimport \"../interfaces/vesper/IController.sol\";\nimport \"../interfaces/vesper/IVesperPool.sol\";\nimport \"../interfaces/bloq/ISwapManager.sol\";\nimport \"../interfaces/bloq/IDescendingPriceAuction.sol\";\nimport \"../../sol-address-list/contracts/interfaces/IAddressListExt.sol\";\nimport \"../../sol-address-list/contracts/interfaces/IAddressListFactory.sol\";\n\ncontract VSPAuctionStrategy is Pausable {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    uint256 public lastRebalanceBlock;\n    IController public immutable controller;\n    IVesperPool public immutable vvsp;\n    IAddressListExt public immutable keepers;\n    ISwapManager public swapManager = ISwapManager(0xe382d9f2394A359B01006faa8A1864b8a60d2710);\n    IDescendingPriceAuction public auctionManager;\n    uint256 public auctionCollectionId;\n    address internal constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n    uint256 internal constant ORACLE_PERIOD = 3600;\n\n    // Auction Config\n    uint256 internal auctionDuration = 600; // 600 Blocks at 12s / block -> ~2hr\n    uint256 internal auctionCeilingBuffer = 2500; // as BP * 10**2\n    uint256 internal auctionFloorBuffer = 2500; // as BP * 10**2\n    uint256 internal acceptableSlippage = 500; // as BP * 10**2\n    address internal auctionPayee;\n\n    uint256 public nextPoolIdx;\n    address[] public pools;\n    uint256[] public liquidationLimit;\n    string public constant NAME = \"Strategy-VSP-Auctions\";\n    string public constant VERSION = \"2.0.0\";\n\n    event UpdatedSwapManager(address indexed previousSwapManager, address indexed newSwapManager);\n    event UpdatedAuctionManager(\n        address indexed previousAuctionManager,\n        address indexed newAuctionManager\n    );\n    event UpdatedAuctionPayee(\n        address indexed previousAuctionPayee,\n        address indexed newAuctionPayee\n    );\n    event UpdatedAuctionConfig(\n        uint256 ceilingBuffer,\n        uint256 floorBuffer,\n        uint256 duration,\n        uint256 previousCeilingBuffer,\n        uint256 previousFloorBuffer,\n        uint256 previousDuration\n    );\n    event UpdatedCollectionId(uint256 previousCollectionId, uint256 newCollectionId);\n    event UpdatedAcceptableSlippage(uint256 previousSlippage, uint256 newSlippage);\n\n    constructor(\n        address _controller,\n        address _vvsp,\n        address _pfDpa\n    ) public {\n        vvsp = IVesperPool(_vvsp);\n        controller = IController(_controller);\n        IAddressListFactory factory =\n            IAddressListFactory(0xD57b41649f822C51a73C44Ba0B3da4A880aF0029);\n        IAddressListExt _keepers = IAddressListExt(factory.createList());\n        _keepers.grantRole(keccak256(\"LIST_ADMIN\"), _controller);\n        keepers = _keepers;\n        auctionManager = IDescendingPriceAuction(_pfDpa);\n        auctionCollectionId = auctionManager.createCollection();\n        auctionPayee = address(this);\n    }\n\n    modifier onlyKeeper() {\n        require(keepers.contains(_msgSender()), \"caller-is-not-keeper\");\n        _;\n    }\n\n    modifier onlyController() {\n        require(_msgSender() == address(controller), \"Caller is not the controller\");\n        _;\n    }\n\n    function pause() external onlyController {\n        _pause();\n    }\n\n    function unpause() external onlyController {\n        _unpause();\n    }\n\n    /**\n     * @notice Update swap manager address\n     * @param _swapManager swap manager address\n     */\n    function updateSwapManager(address _swapManager) external onlyController {\n        require(_swapManager != address(0x0), \"sm-address-is-zero\");\n        require(_swapManager != address(swapManager), \"sm-is-same\");\n        emit UpdatedSwapManager(address(swapManager), _swapManager);\n        swapManager = ISwapManager(_swapManager);\n    }\n\n    function updateAuctionManager(address _auctionManager) external onlyController {\n        require(_auctionManager != address(0x0), \"am-address-is-zero\");\n        require(_auctionManager != address(_auctionManager), \"am-is-same\");\n        emit UpdatedAuctionManager(address(_auctionManager), _auctionManager);\n        auctionManager = IDescendingPriceAuction(_auctionManager);\n        auctionCollectionId = auctionManager.createCollection();\n    }\n\n    // use this to send auction proceeds directly to drip address\n    function updateAuctionPayee(address _payee) external onlyController {\n        require(_payee != address(0x0), \"payee-address-is-zero\");\n        require(_payee != auctionPayee, \"payee-is-same\");\n        emit UpdatedAuctionPayee(auctionPayee, _payee);\n        auctionPayee = _payee;\n    }\n\n    function updateAuctionCollectionId() external onlyController {\n        uint256 newCollectionId = auctionManager.createCollection();\n        emit UpdatedCollectionId(auctionCollectionId, newCollectionId);\n        auctionCollectionId = newCollectionId;\n    }\n\n    function updateAuctionCollectionId(uint256 _collectionId) external onlyController {\n        // DPA does not support checking collection ownership\n        emit UpdatedCollectionId(auctionCollectionId, _collectionId);\n        auctionCollectionId = _collectionId;\n    }\n\n    function updateAcceptableSlippage(uint256 _slippage) external onlyController {\n        require(_slippage < 10000, \"invalid-slippage\");\n        emit UpdatedAcceptableSlippage(acceptableSlippage, _slippage);\n        acceptableSlippage = _slippage;\n    }\n\n    function updateAuctionConfig(\n        uint256 ceilingBuffer,\n        uint256 floorBuffer,\n        uint256 duration\n    ) external onlyController {\n        require(duration != 0, \"duration-is-zero\");\n        require(floorBuffer < 6667, \"invalid-floor-buffer\"); // No greater than 67% drawdown\n        require(ceilingBuffer < 30000, \"invalid-ceil-buffer\"); // No greater than 300% upside\n        emit UpdatedAuctionConfig(\n            ceilingBuffer,\n            floorBuffer,\n            duration,\n            auctionCeilingBuffer,\n            auctionFloorBuffer,\n            auctionDuration\n        );\n        auctionCeilingBuffer = ceilingBuffer;\n        auctionFloorBuffer = floorBuffer;\n        auctionDuration = duration;\n    }\n\n    function _stopAndSwap(DPA memory auction) internal {\n        address[] memory tokens = auction.tokens;\n        auctionManager.stopAuction(auction.id);\n        for (uint256 i = 0; i < tokens.length; i++) {\n            _safeSwapToVsp(tokens[i]);\n        }\n    }\n\n    function _getAuctionsOfCollection() internal view returns (uint256[] memory auctions) {\n        uint256 totalAuctions = auctionManager.collectionLength(auctionCollectionId);\n        auctions = new uint256[](totalAuctions);\n        for (uint256 i = 0; i < totalAuctions; i++) {\n            auctions[i] = auctionManager.auctionOfCollByIndex(auctionCollectionId, i);\n        }\n    }\n\n    function _createAuction(IVesperPool _poolToken, uint256 _poolTokenAmount) internal {\n        // unwrap poolTokens to Tokens ie vWBTC -> WBTC\n        _poolToken.withdrawByStrategy(_poolTokenAmount);\n        address[] memory _tokens = new address[](1);\n        _tokens[0] = _poolToken.token();\n        uint256[] memory _tokenAmounts = new uint256[](1);\n        _tokenAmounts[0] = IERC20(_tokens[0]).balanceOf(address(this));\n\n        address vsp = vvsp.token();\n        // calculate ceiling and floor values\n        (uint256 c, uint256 f) = _getAuctionValues(_tokens, _tokenAmounts, vsp);\n        DPAConfig memory _auction =\n            DPAConfig({\n                ceiling: c,\n                floor: f,\n                collectionId: auctionCollectionId,\n                paymentToken: vsp,\n                payee: auctionPayee,\n                endBlock: block.number + auctionDuration,\n                tokens: _tokens,\n                tokenAmounts: _tokenAmounts\n            });\n        auctionManager.createAuction(_auction);\n    }\n\n    // This should get smarter (use oracles)\n    function _getAuctionValues(\n        address[] memory _tokens,\n        uint256[] memory _tokenAmounts,\n        address _outputToken\n    ) internal returns (uint256 ceiling, uint256 floor) {\n        require(_tokens.length == _tokenAmounts.length, \"invalid-token-list\");\n        uint256 sum;\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            (uint256 amountOut, bool validRate) =\n                _getCompoundOracleRate(_tokens[i], _outputToken, _tokenAmounts[i]);\n            require(validRate, \"stale-oracle-rate\");\n            IERC20(_tokens[i]).approve(address(auctionManager), 0);\n            IERC20(_tokens[i]).approve(address(auctionManager), _tokenAmounts[i]);\n            sum += amountOut;\n        }\n        require(sum != 0, \"cannot-calc-auction-value\");\n        ceiling = sum + ((sum * auctionCeilingBuffer) / 10000);\n        floor = sum - ((sum * auctionFloorBuffer) / 10000);\n    }\n\n    function _safeSwapToVsp(address _fromToken) internal {\n        IERC20 from = IERC20(_fromToken);\n        IERC20 vsp = IERC20(vvsp.token());\n        (address[] memory path, uint256 amountOut, uint256 rIdx) =\n            swapManager.bestOutputFixedInput(\n                _fromToken,\n                address(vsp),\n                from.balanceOf(address(this))\n            );\n        (uint256 expectedAmountOut, bool validRate) =\n            _getCompoundOracleRate(_fromToken, vvsp.token(), from.balanceOf(address(this)));\n        require(validRate, \"stale-oracle-rate\");\n        expectedAmountOut = _calculateSlippage(expectedAmountOut, acceptableSlippage);\n        if (amountOut != 0) {\n            from.safeApprove(address(swapManager.ROUTERS(rIdx)), 0);\n            from.safeApprove(address(swapManager.ROUTERS(rIdx)), from.balanceOf(address(this)));\n            swapManager.ROUTERS(rIdx).swapExactTokensForTokens(\n                from.balanceOf(address(this)),\n                1,\n                path,\n                address(this),\n                now + 30\n            );\n        }\n    }\n\n    function _getCompoundOracleRate(\n        address _from,\n        address _to,\n        uint256 _amt\n    ) internal returns (uint256, bool) {\n        if (_from == WETH || _to == WETH) return _consultOracle(_from, _to, _amt);\n        (uint256 fAmtOut, bool fValid) = _consultOracle(_from, WETH, _amt);\n        (uint256 bRate, bool bValid) = _consultOracle(WETH, _to, fAmtOut);\n        return (bRate, (fValid && bValid));\n    }\n\n    function _consultOracle(\n        address _from,\n        address _to,\n        uint256 _amt\n    ) internal returns (uint256, bool) {\n        // from, to, amountIn, period, router\n        (uint256 rate, uint256 lastUpdate, ) =\n            swapManager.consult(_from, _to, _amt, ORACLE_PERIOD, 0);\n        // We're looking at a TWAP ORACLE with a 1 hr Period that has been updated within the last hour\n        if ((lastUpdate > (block.timestamp - ORACLE_PERIOD)) && (rate != 0)) return (rate, true);\n        return (0, false);\n    }\n\n    function _calculateSlippage(uint256 _amount, uint256 _slippage)\n        internal\n        pure\n        returns (uint256)\n    {\n        return (_amount.mul(uint256(10000).sub(_slippage)).div(10000)).add(1);\n    }\n\n    function killAllAuctions() external onlyController {\n        uint256[] memory auctions = _getAuctionsOfCollection();\n        for (uint256 i = 0; i < auctions.length; i++) {\n            DPA memory a = auctionManager.getAuction(auctions[i]);\n            if (a.winningBlock == 0 && !a.stopped) {\n                _stopAndSwap(a);\n            }\n        }\n    }\n\n    function killAuction(uint256 _auctionId) external onlyController {\n        _stopAndSwap(auctionManager.getAuction(_auctionId));\n    }\n\n    function updateLiquidationQueue(address[] calldata _pools, uint256[] calldata _limit)\n        external\n        onlyController\n    {\n        swapManager.createOrUpdateOracle(vvsp.token(), WETH, ORACLE_PERIOD, 0);\n        for (uint256 i = 0; i < _pools.length; i++) {\n            require(controller.isPool(_pools[i]), \"Not a valid pool\");\n            require(_limit[i] != 0, \"Limit cannot be zero\");\n            if (IVesperPool(_pools[i]).token() != WETH) {\n                swapManager.createOrUpdateOracle(\n                    IVesperPool(_pools[i]).token(),\n                    WETH,\n                    ORACLE_PERIOD,\n                    0\n                );\n            }\n        }\n        pools = _pools;\n        liquidationLimit = _limit;\n        nextPoolIdx = 0;\n    }\n\n    function isUpgradable() external view returns (bool) {\n        return IERC20(vvsp.token()).balanceOf(address(this)) == 0;\n    }\n\n    function pool() external view returns (address) {\n        return address(vvsp);\n    }\n\n    function rebalance() external whenNotPaused onlyKeeper {\n        require(\n            block.number - lastRebalanceBlock >= controller.rebalanceFriction(address(vvsp)),\n            \"Can not rebalance\"\n        );\n        lastRebalanceBlock = block.number;\n\n        // // if any of our auction have hit their floor without being bought, market swap them\n        uint256[] memory auctions = _getAuctionsOfCollection();\n        for (uint256 i = 0; i < auctions.length; i++) {\n            DPA memory a = auctionManager.getAuction(auctions[i]);\n            if (block.number >= a.endBlock && a.winningBlock == 0 && !a.stopped) _stopAndSwap(a);\n        }\n\n        // First, send back any VSP we have received from auctions being completed\n        uint256 vspBalance = IERC20(vvsp.token()).balanceOf(address(this));\n        IERC20(vvsp.token()).safeTransfer(address(vvsp), vspBalance);\n\n        if (nextPoolIdx == pools.length) {\n            nextPoolIdx = 0;\n        }\n\n        IVesperPool _poolToken = IVesperPool(pools[nextPoolIdx]);\n        uint256 _balance = _poolToken.balanceOf(address(vvsp));\n        if (_balance != 0 && address(_poolToken) != address(vvsp)) {\n            if (_balance > liquidationLimit[nextPoolIdx]) {\n                _balance = liquidationLimit[nextPoolIdx];\n            }\n            IERC20(address(_poolToken)).safeTransferFrom(address(vvsp), address(this), _balance);\n            _createAuction(_poolToken, _balance);\n        }\n        nextPoolIdx++;\n    }\n\n    /// @dev sweep given token to vsp pool\n    function sweepErc20(address _fromToken) external {\n        uint256 amount = IERC20(_fromToken).balanceOf(address(this));\n        IERC20(_fromToken).safeTransfer(address(vvsp), amount);\n    }\n}\n"
    },
    "contracts/interfaces/bloq/IDescendingPriceAuction.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nstruct DPAConfig {\n    uint256 ceiling;\n    uint256 floor;\n    uint256 collectionId;\n    address paymentToken;\n    address payee;\n    uint256 endBlock;\n    address[] tokens;\n    uint256[] tokenAmounts;\n}\n\nstruct DPA {\n    uint256 id;\n    uint256 ceiling;\n    uint256 floor;\n    uint256 absoluteDecay;\n    uint256 collectionId;\n    address paymentToken;\n    address payee;\n    uint256 startBlock;\n    uint256 endBlock;\n    bool stopped;\n    address winner;\n    uint256 winningBlock;\n    uint256 winningPrice;\n    address[] tokens;\n    uint256[] tokenAmounts;\n}\n\ninterface IDescendingPriceAuction {\n    event AuctionCreated(uint256 id, uint256 collectionId, address auctioneer);\n    event CollectionCreated(uint256 id, address owner);\n    event CollectionTransfer(uint256 id, address from, address to);\n    event AuctionStopped(uint256 id);\n    event AuctionWon(uint256 id, uint256 price, address paymentToken, address winner);\n\n    function getAuction(uint256 _id) external view returns (DPA memory);\n\n    function totalAuctions() external view returns (uint256);\n\n    function totalCollections() external view returns (uint256);\n\n    function collectionLength(uint256 _id) external view returns (uint256);\n\n    function neerGroupLength(address _neer) external view returns (uint256);\n\n    function auctionOfNeerByIndex(address _neer, uint256 i) external view returns (uint256);\n\n    function auctionOfCollByIndex(uint256 _id, uint256 i) external view returns (uint256);\n\n    function createAuction(DPAConfig memory _auction) external returns (uint256);\n\n    function stopAuction(uint256 _id) external;\n\n    function bid(uint256 _id) external;\n\n    function getCurrentPrice(uint256 _id) external view returns (uint256);\n\n    function createCollection() external returns (uint256);\n\n    function transferCollection(address _to, uint256 _id) external;\n}\n"
    },
    "contracts/test/DescendingPriceAuction.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/utils/Counters.sol\";\nimport \"@openzeppelin/contracts/utils/EnumerableSet.sol\";\nimport \"@openzeppelin/contracts/utils/EnumerableMap.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"../interfaces/bloq/IDescendingPriceAuction.sol\";\n\ncontract DescendingPriceAuction is IDescendingPriceAuction {\n    using SafeERC20 for IERC20;\n    using Counters for Counters.Counter;\n    using EnumerableSet for EnumerableSet.UintSet;\n    using EnumerableMap for EnumerableMap.UintToAddressMap;\n\n    mapping(uint256 => DPA) private auctions;\n    EnumerableMap.UintToAddressMap private collections;\n    EnumerableMap.UintToAddressMap private auctioneers;\n    Counters.Counter private collectionCount;\n    Counters.Counter private auctionCount;\n\n    // Mapping from aucitoneer address to their (enumerable) set of auctions\n    mapping(address => EnumerableSet.UintSet) private _byNeer;\n\n    // Mapping from collectionId to its (enumerable) set of auctions\n    mapping(uint256 => EnumerableSet.UintSet) private _byColl;\n\n    constructor() public {\n        // Start the counts at 1\n        // the 0th collection is available to all\n        auctionCount.increment();\n        collectionCount.increment();\n    }\n\n    function _msgSender() internal view returns (address) {\n        return msg.sender;\n    }\n\n    modifier onlyAuctioneer(uint256 _id) {\n        (bool success, address neer) = auctioneers.tryGet(_id);\n        require(success, \"non-existent-auction\");\n        require(_msgSender() == neer, \"caller-not-auctioneer\");\n        _;\n    }\n\n    modifier onlyCollectionOwner(uint256 _id) {\n        // anyone can create an auction in the 0th collection\n        if (_id != 0) {\n            (bool success, address owner) = collections.tryGet(_id);\n            require(success, \"non-existent-collection\");\n            require(_msgSender() == owner, \"caller-not-collection-owner\");\n        }\n        _;\n    }\n\n    function getAuction(uint256 _id) external view override returns (DPA memory) {\n        return auctions[_id];\n    }\n\n    function totalAuctions() external view override returns (uint256) {\n        return auctioneers.length();\n    }\n\n    function totalCollections() external view override returns (uint256) {\n        return collections.length();\n    }\n\n    function collectionLength(uint256 _id) external view override returns (uint256) {\n        return _byColl[_id].length();\n    }\n\n    function neerGroupLength(address _neer) external view override returns (uint256) {\n        return _byNeer[_neer].length();\n    }\n\n    // return AuctionId\n    function auctionOfNeerByIndex(address _neer, uint256 i)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return _byNeer[_neer].at(i);\n    }\n\n    // return AuctionId\n    function auctionOfCollByIndex(uint256 _id, uint256 i) external view override returns (uint256) {\n        return _byColl[_id].at(i);\n    }\n\n    function _auctionExists(uint256 _auctionId) internal view virtual returns (bool) {\n        return auctioneers.contains(_auctionId);\n    }\n\n    function createAuction(DPAConfig memory _auction)\n        external\n        override\n        onlyCollectionOwner(_auction.collectionId)\n        returns (uint256)\n    {\n        require(_auction.endBlock > block.number, \"end-block-passed\");\n        require(_auction.ceiling != 0, \"start-price-zero\");\n        require(_auction.ceiling >= _auction.floor, \"invalid-pricing\");\n        require(_auction.paymentToken != address(0x0), \"invalid-payment-token\");\n        require(_auction.payee != address(0x0), \"invalid-payee\");\n        require(_auction.tokens.length != 0, \"no-line-items\");\n        require(_auction.tokens.length == _auction.tokenAmounts.length, \"improper-line-items\");\n        require(_auction.tokens.length < 8, \"too-many-line-items\");\n        return _createAuction(_auction);\n    }\n\n    function _createAuction(DPAConfig memory _auction) internal returns (uint256) {\n        _pullTokens(_auction.tokens, _auction.tokenAmounts);\n        uint256 id = auctionCount.current();\n        uint256 decay =\n            _calulateAbsoluteDecay(\n                _auction.ceiling,\n                _auction.floor,\n                block.number,\n                _auction.endBlock\n            );\n        auctions[id] = DPA({\n            id: id,\n            ceiling: _auction.ceiling,\n            floor: _auction.floor,\n            absoluteDecay: decay,\n            collectionId: _auction.collectionId,\n            paymentToken: _auction.paymentToken,\n            payee: _auction.payee,\n            startBlock: block.number,\n            endBlock: _auction.endBlock,\n            stopped: false,\n            winner: address(0x0),\n            winningBlock: 0,\n            winningPrice: 0,\n            tokens: _auction.tokens,\n            tokenAmounts: _auction.tokenAmounts\n        });\n        address neer = _msgSender();\n        auctioneers.set(id, neer);\n        _byNeer[neer].add(id);\n        _byColl[_auction.collectionId].add(id);\n        auctionCount.increment();\n        emit AuctionCreated(id, _auction.collectionId, neer);\n        return id;\n    }\n\n    function _pullTokens(address[] memory tokens, uint256[] memory amounts) internal {\n        for (uint256 i = 0; i < tokens.length; i++) {\n            _pullToken(tokens[i], amounts[i]);\n        }\n    }\n\n    function _pullToken(address _token, uint256 _amount) internal {\n        require(_amount != 0, \"invalid-token-amount\");\n        _safeTransferFromExact(_token, _msgSender(), address(this), _amount);\n    }\n\n    function _sendTokens(\n        address recipient,\n        address[] memory tokens,\n        uint256[] memory amounts\n    ) internal {\n        for (uint256 i = 0; i < tokens.length; i++) {\n            IERC20(tokens[i]).safeTransfer(recipient, amounts[i]);\n        }\n    }\n\n    function stopAuction(uint256 _id) external override onlyAuctioneer(_id) {\n        DPA memory auction = auctions[_id];\n        require(auction.winner == address(0x0) && !auction.stopped, \"cant-be-stopped\");\n        _sendTokens(auctioneers.get(_id), auction.tokens, auction.tokenAmounts);\n        auctions[_id].stopped = true;\n        emit AuctionStopped(_id);\n    }\n\n    function bid(uint256 _id) external override {\n        require(_auctionExists(_id), \"no-such-auction-id\");\n        DPA memory auction = auctions[_id];\n        require(auction.winner == address(0x0), \"auction-has-ended\");\n        require(!auction.stopped, \"auction-has-been-stopped\");\n        uint256 price =\n            _getCurrentPrice(auction.absoluteDecay, auction.floor, auction.endBlock, block.number);\n        address bidder = _msgSender();\n        _safeTransferFromExact(auction.paymentToken, bidder, auction.payee, price);\n        _sendTokens(bidder, auction.tokens, auction.tokenAmounts);\n        auction.stopped = true;\n        auction.winner = bidder;\n        auction.winningBlock = block.number;\n        auction.winningPrice = price;\n        auctions[_id] = auction;\n        emit AuctionWon(_id, price, auction.paymentToken, bidder);\n    }\n\n    function getCurrentPrice(uint256 _id) external view override returns (uint256) {\n        require(_auctionExists(_id), \"no-such-auction-id\");\n        DPA memory a = auctions[_id];\n        return _getCurrentPrice(a.absoluteDecay, a.floor, a.endBlock, block.number);\n    }\n\n    function _getCurrentPrice(\n        uint256 m,\n        uint256 f,\n        uint256 e,\n        uint256 t\n    ) internal pure returns (uint256 p) {\n        if (t > e) return f;\n        if (m == 0) return f;\n        // we know m is actually negative, so we're solving y=-mx+b (p = -(m * t) + b)\n        uint256 b = f + ((m * e) / 1e18);\n        p = b - ((m * t) / 1e18);\n    }\n\n    function _calulateAbsoluteDecay(\n        uint256 c,\n        uint256 f,\n        uint256 s,\n        uint256 e\n    ) internal pure returns (uint256) {\n        require(e > s, \"invalid-ramp\");\n        require(c >= f, \"price-not-descending-or-const\");\n        return ((c - f) * 1e18) / (e - s);\n    }\n\n    function _safeTransferFromExact(\n        address _token,\n        address _from,\n        address _to,\n        uint256 _amount\n    ) internal {\n        IERC20 token = IERC20(_token);\n        uint256 before = token.balanceOf(_to);\n        token.safeTransferFrom(_from, _to, _amount);\n        require(token.balanceOf(_to) - before == _amount, \"not-enough-transferred\");\n    }\n\n    function createCollection() external override returns (uint256) {\n        uint256 id = collectionCount.current();\n        address owner = _msgSender();\n        collections.set(id, owner);\n        collectionCount.increment();\n        emit CollectionCreated(id, owner);\n        return id;\n    }\n\n    function transferCollection(address _to, uint256 _id)\n        external\n        override\n        onlyCollectionOwner(_id)\n    {\n        collections.set(_id, _to);\n        emit CollectionTransfer(_id, _msgSender(), _to);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Counters.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../math/SafeMath.sol\";\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented or decremented by one. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n * Since it is not possible to overflow a 256 bit integer with increments of one, `increment` can skip the {SafeMath}\n * overflow check, thereby saving gas. This does assume however correct usage, in that the underlying `_value` is never\n * directly accessed.\n */\nlibrary Counters {\n    using SafeMath for uint256;\n\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        // The {SafeMath} overflow check can be skipped here, see the comment at the top\n        counter._value += 1;\n    }\n\n    function decrement(Counter storage counter) internal {\n        counter._value = counter._value.sub(1);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping (bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) { // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\n\n            bytes32 lastvalue = set._values[lastIndex];\n\n            // Move the last value to the index where the value to delete is\n            set._values[toDeleteIndex] = lastvalue;\n            // Update the index for the moved value\n            set._indexes[lastvalue] = toDeleteIndex + 1; // All indexes are 1-based\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        require(set._values.length > index, \"EnumerableSet: index out of bounds\");\n        return set._values[index];\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/EnumerableMap.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Library for managing an enumerable variant of Solidity's\n * https://solidity.readthedocs.io/en/latest/types.html#mapping-types[`mapping`]\n * type.\n *\n * Maps have the following properties:\n *\n * - Entries are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Entries are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableMap for EnumerableMap.UintToAddressMap;\n *\n *     // Declare a set state variable\n *     EnumerableMap.UintToAddressMap private myMap;\n * }\n * ```\n *\n * As of v3.0.0, only maps of type `uint256 -> address` (`UintToAddressMap`) are\n * supported.\n */\nlibrary EnumerableMap {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Map type with\n    // bytes32 keys and values.\n    // The Map implementation uses private functions, and user-facing\n    // implementations (such as Uint256ToAddressMap) are just wrappers around\n    // the underlying Map.\n    // This means that we can only create new EnumerableMaps for types that fit\n    // in bytes32.\n\n    struct MapEntry {\n        bytes32 _key;\n        bytes32 _value;\n    }\n\n    struct Map {\n        // Storage of map keys and values\n        MapEntry[] _entries;\n\n        // Position of the entry defined by a key in the `entries` array, plus 1\n        // because index 0 means a key is not in the map.\n        mapping (bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function _set(Map storage map, bytes32 key, bytes32 value) private returns (bool) {\n        // We read and store the key's index to prevent multiple reads from the same storage slot\n        uint256 keyIndex = map._indexes[key];\n\n        if (keyIndex == 0) { // Equivalent to !contains(map, key)\n            map._entries.push(MapEntry({ _key: key, _value: value }));\n            // The entry is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            map._indexes[key] = map._entries.length;\n            return true;\n        } else {\n            map._entries[keyIndex - 1]._value = value;\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a key-value pair from a map. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function _remove(Map storage map, bytes32 key) private returns (bool) {\n        // We read and store the key's index to prevent multiple reads from the same storage slot\n        uint256 keyIndex = map._indexes[key];\n\n        if (keyIndex != 0) { // Equivalent to contains(map, key)\n            // To delete a key-value pair from the _entries array in O(1), we swap the entry to delete with the last one\n            // in the array, and then remove the last entry (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = keyIndex - 1;\n            uint256 lastIndex = map._entries.length - 1;\n\n            // When the entry to delete is the last one, the swap operation is unnecessary. However, since this occurs\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\n\n            MapEntry storage lastEntry = map._entries[lastIndex];\n\n            // Move the last entry to the index where the entry to delete is\n            map._entries[toDeleteIndex] = lastEntry;\n            // Update the index for the moved entry\n            map._indexes[lastEntry._key] = toDeleteIndex + 1; // All indexes are 1-based\n\n            // Delete the slot where the moved entry was stored\n            map._entries.pop();\n\n            // Delete the index for the deleted slot\n            delete map._indexes[key];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function _contains(Map storage map, bytes32 key) private view returns (bool) {\n        return map._indexes[key] != 0;\n    }\n\n    /**\n     * @dev Returns the number of key-value pairs in the map. O(1).\n     */\n    function _length(Map storage map) private view returns (uint256) {\n        return map._entries.length;\n    }\n\n   /**\n    * @dev Returns the key-value pair stored at position `index` in the map. O(1).\n    *\n    * Note that there are no guarantees on the ordering of entries inside the\n    * array, and it may change when more entries are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function _at(Map storage map, uint256 index) private view returns (bytes32, bytes32) {\n        require(map._entries.length > index, \"EnumerableMap: index out of bounds\");\n\n        MapEntry storage entry = map._entries[index];\n        return (entry._key, entry._value);\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`.  O(1).\n     * Does not revert if `key` is not in the map.\n     */\n    function _tryGet(Map storage map, bytes32 key) private view returns (bool, bytes32) {\n        uint256 keyIndex = map._indexes[key];\n        if (keyIndex == 0) return (false, 0); // Equivalent to contains(map, key)\n        return (true, map._entries[keyIndex - 1]._value); // All indexes are 1-based\n    }\n\n    /**\n     * @dev Returns the value associated with `key`.  O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function _get(Map storage map, bytes32 key) private view returns (bytes32) {\n        uint256 keyIndex = map._indexes[key];\n        require(keyIndex != 0, \"EnumerableMap: nonexistent key\"); // Equivalent to contains(map, key)\n        return map._entries[keyIndex - 1]._value; // All indexes are 1-based\n    }\n\n    /**\n     * @dev Same as {_get}, with a custom error message when `key` is not in the map.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {_tryGet}.\n     */\n    function _get(Map storage map, bytes32 key, string memory errorMessage) private view returns (bytes32) {\n        uint256 keyIndex = map._indexes[key];\n        require(keyIndex != 0, errorMessage); // Equivalent to contains(map, key)\n        return map._entries[keyIndex - 1]._value; // All indexes are 1-based\n    }\n\n    // UintToAddressMap\n\n    struct UintToAddressMap {\n        Map _inner;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(UintToAddressMap storage map, uint256 key, address value) internal returns (bool) {\n        return _set(map._inner, bytes32(key), bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(UintToAddressMap storage map, uint256 key) internal returns (bool) {\n        return _remove(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(UintToAddressMap storage map, uint256 key) internal view returns (bool) {\n        return _contains(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Returns the number of elements in the map. O(1).\n     */\n    function length(UintToAddressMap storage map) internal view returns (uint256) {\n        return _length(map._inner);\n    }\n\n   /**\n    * @dev Returns the element stored at position `index` in the set. O(1).\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(UintToAddressMap storage map, uint256 index) internal view returns (uint256, address) {\n        (bytes32 key, bytes32 value) = _at(map._inner, index);\n        return (uint256(key), address(uint160(uint256(value))));\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`.  O(1).\n     * Does not revert if `key` is not in the map.\n     *\n     * _Available since v3.4._\n     */\n    function tryGet(UintToAddressMap storage map, uint256 key) internal view returns (bool, address) {\n        (bool success, bytes32 value) = _tryGet(map._inner, bytes32(key));\n        return (success, address(uint160(uint256(value))));\n    }\n\n    /**\n     * @dev Returns the value associated with `key`.  O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(UintToAddressMap storage map, uint256 key) internal view returns (address) {\n        return address(uint160(uint256(_get(map._inner, bytes32(key)))));\n    }\n\n    /**\n     * @dev Same as {get}, with a custom error message when `key` is not in the map.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryGet}.\n     */\n    function get(UintToAddressMap storage map, uint256 key, string memory errorMessage) internal view returns (address) {\n        return address(uint160(uint256(_get(map._inner, bytes32(key), errorMessage))));\n    }\n}\n"
    },
    "contracts/strategies/VesperV3Strategy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"../interfaces/vesper/IController.sol\";\nimport \"./Strategy.sol\";\nimport \"../interfaces/bloq/ISwapManager.sol\";\nimport \"../interfaces/vesper/IVesperPoolV3.sol\";\nimport \"../interfaces/vesper/IStrategyV3.sol\";\nimport \"../interfaces/vesper/IPoolRewardsV3.sol\";\n\n/// @title This strategy will deposit collateral token in VesperV3 and earn interest.\nabstract contract VesperV3Strategy is Strategy {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    IVesperPoolV3 internal immutable vToken;\n\n    constructor(\n        address _controller,\n        address _pool,\n        address _receiptToken\n    ) public Strategy(_controller, _pool, _receiptToken) {\n        vToken = IVesperPoolV3(_receiptToken);\n    }\n\n    /**\n     * @notice Migrate tokens from pool to this address\n     * @dev Any working VesperV3 strategy has vTokens in strategy contract.\n     * @dev There can be scenarios when pool already has vTokens and new\n     * strategy will have to move those tokens from pool to self address.\n     * @dev Only valid pool strategy is allowed to move tokens from pool.\n     */\n    function _migrateIn() internal override {\n        require(controller.isPool(pool), \"not-a-valid-pool\");\n        require(controller.strategy(pool) == address(this), \"not-a-valid-strategy\");\n        IERC20(vToken).safeTransferFrom(pool, address(this), vToken.balanceOf(pool));\n    }\n\n    /**\n     * @notice Migrate tokens out to pool.\n     * @dev There can be scenarios when we want to use new strategy without\n     * calling withdrawAll(). We can achieve this by moving tokens in pool\n     * and new strategy will take care from there.\n     * @dev Pause this strategy and move tokens out.\n     */\n    function _migrateOut() internal override {\n        require(controller.isPool(pool), \"not-a-valid-pool\");\n        _pause();\n        IERC20(vToken).safeTransfer(pool, vToken.balanceOf(address(this)));\n    }\n\n    /// @notice Vesper pools are using this function so it should exist in all strategies.\n    //solhint-disable-next-line no-empty-blocks\n    function beforeWithdraw() external override onlyPool {}\n\n    /**\n     * @dev Calculate interest fee on earning from VesperV3 and transfer fee to fee collector.\n     * Deposit available collateral from pool into VesperV3.\n     * Anyone can call it except when paused.\n     */\n    function rebalance() external override whenNotPaused onlyKeeper {\n        _claimReward();\n        uint256 balance = collateralToken.balanceOf(pool);\n        if (balance != 0) {\n            _deposit(balance);\n        }\n    }\n\n    /**\n     * @notice Returns interest earned since last rebalance.\n     */\n    function interestEarned() public view override returns (uint256 collateralEarned) {\n        // V3 Pool rewardToken can change over time so we don't store it in contract\n        address _poolRewards = vToken.poolRewards();\n        if (_poolRewards != address(0)) {\n            address _rewardToken = IPoolRewardsV3(_poolRewards).rewardToken();\n            uint256 _claimableRewards = IPoolRewardsV3(_poolRewards).claimable(address(this));\n            // if there's any reward earned we add that to collateralEarned\n            if (_claimableRewards != 0) {\n                (, collateralEarned, ) = swapManager.bestOutputFixedInput(\n                    _rewardToken,\n                    address(collateralToken),\n                    _claimableRewards\n                );\n            }\n        }\n\n        address[] memory _strategies = vToken.getStrategies();\n        uint256 _len = _strategies.length;\n        uint256 _unrealizedGain;\n\n        for (uint256 i = 0; i < _len; i++) {\n            uint256 _totalValue = IStrategyV3(_strategies[i]).totalValue();\n            uint256 _debt = vToken.totalDebtOf(_strategies[i]);\n            if (_totalValue > _debt) {\n                _unrealizedGain = _unrealizedGain.add(_totalValue.sub(_debt));\n            }\n        }\n\n        if (_unrealizedGain != 0) {\n            // collateralEarned = rewards + unrealizedGain proportional to v2 share in v3\n            collateralEarned = collateralEarned.add(\n                _unrealizedGain.mul(vToken.balanceOf(address(this))).div(vToken.totalSupply())\n            );\n        }\n    }\n\n    /// @notice Returns true if strategy can be upgraded.\n    /// @dev If there are no vTokens in strategy then it is upgradable\n    function isUpgradable() external view override returns (bool) {\n        return vToken.balanceOf(address(this)) == 0;\n    }\n\n    /// @notice This method is deprecated and will be removed from Strategies in next release\n    function isReservedToken(address _token) public view override returns (bool) {\n        address _poolRewards = vToken.poolRewards();\n        return\n            _token == address(vToken) ||\n            (_poolRewards != address(0) && _token == IPoolRewardsV3(_poolRewards).rewardToken());\n    }\n\n    function _approveToken(uint256 _amount) internal override {\n        collateralToken.safeApprove(pool, _amount);\n        collateralToken.safeApprove(address(vToken), _amount);\n        address _poolRewards = vToken.poolRewards();\n        if (_poolRewards != address(0)) {\n            address _rewardToken = IPoolRewardsV3(_poolRewards).rewardToken();\n            for (uint256 i = 0; i < swapManager.N_DEX(); i++) {\n                IERC20(_rewardToken).safeApprove(address(swapManager.ROUTERS(i)), _amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Converts rewardToken from V3 Pool to collateralToken\n     * @notice V3 Pools will claim rewardToken onbehalf of caller on every withdraw/deposit\n     */\n    function _claimReward() internal override {\n        // V3 Pool rewardToken can change over time so we don't store it in contract\n        address _poolRewards = vToken.poolRewards();\n        if (_poolRewards != address(0)) {\n            IERC20 _rewardToken = IERC20(IPoolRewardsV3(_poolRewards).rewardToken());\n            uint256 _rewardAmount = _rewardToken.balanceOf(address(this));\n            if (_rewardAmount != 0)\n                _safeSwap(address(_rewardToken), address(collateralToken), _rewardAmount);\n        }\n    }\n\n    /**\n     * @notice Total collateral locked in VesperV3.\n     * @return Return value will be in collateralToken defined decimal.\n     */\n    function totalLocked() public view override returns (uint256) {\n        uint256 _totalVTokens = vToken.balanceOf(pool).add(vToken.balanceOf(address(this)));\n        return _convertToCollateral(_totalVTokens);\n    }\n\n    function _deposit(uint256 _amount) internal virtual override {\n        collateralToken.safeTransferFrom(pool, address(this), _amount);\n        vToken.deposit(_amount);\n    }\n\n    function _withdraw(uint256 _amount) internal override {\n        _safeWithdraw(_convertToShares(_amount));\n        collateralToken.safeTransfer(pool, collateralToken.balanceOf(address(this)));\n    }\n\n    /**\n     * @dev V3 Pools may withdraw a partial amount of requested shares\n     * Resulting in more burnt shares than actual collateral in V2\n     * We make sure burnt shares equals to our expected value\n     */\n    function _safeWithdraw(uint256 _shares) internal {\n        uint256 _maxShares = vToken.balanceOf(address(this));\n\n        if (_shares != 0) {\n            vToken.withdraw(_shares);\n\n            require(\n                vToken.balanceOf(address(this)) == _maxShares.sub(_shares),\n                \"Not enough shares withdrawn\"\n            );\n        }\n    }\n\n    function _withdrawAll() internal override {\n        _safeWithdraw(vToken.balanceOf(address(this)));\n        _claimReward();\n        collateralToken.safeTransfer(pool, collateralToken.balanceOf(address(this)));\n    }\n\n    function _convertToCollateral(uint256 _vTokenAmount) internal view returns (uint256) {\n        uint256 _totalSupply = vToken.totalSupply();\n        // avoids division by zero error when pool is empty\n        return (_totalSupply != 0) ? vToken.totalValue().mul(_vTokenAmount).div(_totalSupply) : 0;\n    }\n\n    function _convertToShares(uint256 _collateralAmount) internal view returns (uint256) {\n        return _collateralAmount.mul(vToken.totalSupply()).div(vToken.totalValue());\n    }\n\n    /**\n     * @notice Returns interest earned since last rebalance.\n     * @dev Empty implementation because V3 Strategies should collect pending interest fee\n     */\n    //solhint-disable-next-line no-empty-blocks\n    function _updatePendingFee() internal override {}\n}\n"
    },
    "contracts/strategies/Strategy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"../Pausable.sol\";\nimport \"../interfaces/bloq/ISwapManager.sol\";\nimport \"../interfaces/vesper/IController.sol\";\nimport \"../interfaces/vesper/IStrategy.sol\";\nimport \"../interfaces/vesper/IVesperPool.sol\";\nimport \"../../sol-address-list/contracts/interfaces/IAddressListExt.sol\";\nimport \"../../sol-address-list/contracts/interfaces/IAddressListFactory.sol\";\n\nabstract contract Strategy is IStrategy, Pausable {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    // solhint-disable-next-line\n    ISwapManager public swapManager = ISwapManager(0xe382d9f2394A359B01006faa8A1864b8a60d2710);\n    IController public immutable controller;\n    IERC20 public immutable collateralToken;\n    address public immutable receiptToken;\n    address public immutable override pool;\n    IAddressListExt public keepers;\n    address internal constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n    address internal constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n    uint256 internal constant MAX_UINT_VALUE = type(uint256).max;\n\n    event UpdatedSwapManager(address indexed previousSwapManager, address indexed newSwapManager);\n\n    constructor(\n        address _controller,\n        address _pool,\n        address _receiptToken\n    ) public {\n        require(_controller != address(0), \"controller-address-is-zero\");\n        require(IController(_controller).isPool(_pool), \"not-a-valid-pool\");\n        controller = IController(_controller);\n        pool = _pool;\n        collateralToken = IERC20(IVesperPool(_pool).token());\n        receiptToken = _receiptToken;\n    }\n\n    modifier onlyAuthorized() {\n        require(\n            _msgSender() == address(controller) || _msgSender() == pool,\n            \"caller-is-not-authorized\"\n        );\n        _;\n    }\n\n    modifier onlyController() {\n        require(_msgSender() == address(controller), \"caller-is-not-the-controller\");\n        _;\n    }\n\n    modifier onlyKeeper() {\n        require(keepers.contains(_msgSender()), \"caller-is-not-keeper\");\n        _;\n    }\n\n    modifier onlyPool() {\n        require(_msgSender() == pool, \"caller-is-not-the-pool\");\n        _;\n    }\n\n    function pause() external override onlyController {\n        _pause();\n    }\n\n    function unpause() external override onlyController {\n        _unpause();\n    }\n\n    /// @dev Approve all required tokens\n    function approveToken() external onlyController {\n        _approveToken(0);\n        _approveToken(MAX_UINT_VALUE);\n    }\n\n    /// @dev Reset approval of all required tokens\n    function resetApproval() external onlyController {\n        _approveToken(0);\n    }\n\n    /**\n     * @notice Create keeper list\n     * @dev Create keeper list\n     * NOTE: Any function with onlyKeeper modifier will not work until this function is called.\n     * NOTE: Due to gas constraint this function cannot be called in constructor.\n     */\n    function createKeeperList() external onlyController {\n        require(address(keepers) == address(0), \"keeper-list-already-created\");\n        IAddressListFactory factory =\n            IAddressListFactory(0xD57b41649f822C51a73C44Ba0B3da4A880aF0029);\n        keepers = IAddressListExt(factory.createList());\n        keepers.grantRole(keccak256(\"LIST_ADMIN\"), _msgSender());\n    }\n\n    /**\n     * @notice Update swap manager address\n     * @param _swapManager swap manager address\n     */\n    function updateSwapManager(address _swapManager) external onlyController {\n        require(_swapManager != address(0), \"sm-address-is-zero\");\n        require(_swapManager != address(swapManager), \"sm-is-same\");\n        emit UpdatedSwapManager(address(swapManager), _swapManager);\n        swapManager = ISwapManager(_swapManager);\n    }\n\n    /**\n     * @dev Deposit collateral token into lending pool.\n     * @param _amount Amount of collateral token\n     */\n    function deposit(uint256 _amount) public override onlyKeeper {\n        _updatePendingFee();\n        _deposit(_amount);\n    }\n\n    /**\n     * @notice Deposit all collateral token from pool to other lending pool.\n     * Anyone can call it except when paused.\n     */\n    function depositAll() external virtual onlyKeeper {\n        deposit(collateralToken.balanceOf(pool));\n    }\n\n    /**\n     * @dev Withdraw collateral token from lending pool.\n     * @param _amount Amount of collateral token\n     */\n    function withdraw(uint256 _amount) external override onlyAuthorized {\n        _updatePendingFee();\n        _withdraw(_amount);\n    }\n\n    /**\n     * @dev Withdraw all collateral. No rebalance earning.\n     * Controller only function, called when migrating strategy.\n     */\n    function withdrawAll() external override onlyController {\n        _withdrawAll();\n    }\n\n    /**\n     * @dev sweep given token to vesper pool\n     * @param _fromToken token address to sweep\n     */\n    function sweepErc20(address _fromToken) external onlyKeeper {\n        require(!isReservedToken(_fromToken), \"not-allowed-to-sweep\");\n        if (_fromToken == ETH) {\n            Address.sendValue(payable(pool), address(this).balance);\n        } else {\n            uint256 _amount = IERC20(_fromToken).balanceOf(address(this));\n            IERC20(_fromToken).safeTransfer(pool, _amount);\n        }\n    }\n\n    /// @dev Returns true if strategy can be upgraded.\n    function isUpgradable() external view virtual override returns (bool) {\n        return totalLocked() == 0;\n    }\n\n    /// @dev Returns address of token correspond to collateral token\n    function token() external view override returns (address) {\n        return receiptToken;\n    }\n\n    /// @dev Convert from 18 decimals to token defined decimals. Default no conversion.\n    function convertFrom18(uint256 amount) public pure virtual returns (uint256) {\n        return amount;\n    }\n\n    /// @dev report the interest earned since last rebalance\n    function interestEarned() external view virtual returns (uint256);\n\n    /// @dev Check whether given token is reserved or not. Reserved tokens are not allowed to sweep.\n    function isReservedToken(address _token) public view virtual override returns (bool);\n\n    /// @dev Returns total collateral locked here\n    function totalLocked() public view virtual override returns (uint256);\n\n    /// @dev For moving between versions of similar strategies\n    function migrateIn() external onlyController {\n        _migrateIn();\n    }\n\n    /// @dev For moving between versions of similar strategies\n    function migrateOut() external onlyController {\n        _migrateOut();\n    }\n\n    /**\n     * @notice Handle earned interest fee\n     * @dev Earned interest fee will go to the fee collector. We want fee to be in form of Vepseer\n     * pool tokens not in collateral tokens so we will deposit fee in Vesper pool and send vTokens\n     * to fee collactor.\n     * @param _fee Earned interest fee in collateral token.\n     */\n    function _handleFee(uint256 _fee) internal virtual {\n        if (_fee != 0) {\n            IVesperPool(pool).deposit(_fee);\n            uint256 _feeInVTokens = IERC20(pool).balanceOf(address(this));\n            IERC20(pool).safeTransfer(controller.feeCollector(pool), _feeInVTokens);\n        }\n    }\n\n    /**\n     * @notice Safe swap via Uniswap\n     * @dev There are many scenarios when token swap via Uniswap can fail, so this\n     * method will wrap Uniswap call in a 'try catch' to make it fail safe.\n     * @param _from address of from token\n     * @param _to address of to token\n     * @param _amount Amount to be swapped\n     */\n    function _safeSwap(\n        address _from,\n        address _to,\n        uint256 _amount\n    ) internal {\n        (address[] memory _path, uint256 amountOut, uint256 rIdx) =\n            swapManager.bestOutputFixedInput(_from, _to, _amount);\n        if (amountOut != 0) {\n            swapManager.ROUTERS(rIdx).swapExactTokensForTokens(\n                _amount,\n                1,\n                _path,\n                address(this),\n                block.timestamp + 30\n            );\n        }\n    }\n\n    function _deposit(uint256 _amount) internal virtual;\n\n    function _withdraw(uint256 _amount) internal virtual;\n\n    function _approveToken(uint256 _amount) internal virtual;\n\n    function _updatePendingFee() internal virtual;\n\n    function _withdrawAll() internal virtual;\n\n    function _migrateIn() internal virtual;\n\n    function _migrateOut() internal virtual;\n\n    function _claimReward() internal virtual;\n}\n"
    },
    "contracts/interfaces/vesper/IVesperPoolV3.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IVesperPoolV3 is IERC20 {\n    function deposit() external payable;\n\n    function deposit(uint256 _share) external;\n\n    function governor() external returns (address);\n\n    function keepers() external returns (address);\n\n    function multiTransfer(address[] memory _recipients, uint256[] memory _amounts)\n        external\n        returns (bool);\n\n    function excessDebt(address _strategy) external view returns (uint256);\n\n    function permit(\n        address,\n        address,\n        uint256,\n        uint256,\n        uint8,\n        bytes32,\n        bytes32\n    ) external;\n\n    function reportEarning(\n        uint256 _profit,\n        uint256 _loss,\n        uint256 _payback\n    ) external;\n\n    function resetApproval() external;\n\n    function sweepERC20(address _fromToken) external;\n\n    function withdraw(uint256 _amount) external;\n\n    function withdrawETH(uint256 _amount) external;\n\n    function whitelistedWithdraw(uint256 _amount) external;\n\n    function feeCollector() external view returns (address);\n\n    function pricePerShare() external view returns (uint256);\n\n    function token() external view returns (address);\n\n    function tokensHere() external view returns (uint256);\n\n    function totalDebtOf(address _strategy) external view returns (uint256);\n\n    function totalValue() external view returns (uint256);\n\n    function withdrawFee() external view returns (uint256);\n\n    function poolRewards() external view returns (address);\n\n    function getStrategies() external view returns (address[] memory);\n}\n"
    },
    "contracts/interfaces/vesper/IStrategyV3.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\ninterface IStrategyV3 {\n    function totalValue() external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/vesper/IPoolRewardsV3.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\ninterface IPoolRewardsV3 {\n    /// Emitted after reward added\n    event RewardAdded(uint256 reward);\n    /// Emitted whenever any user claim rewards\n    event RewardPaid(address indexed user, uint256 reward);\n    /// Emitted when reward is ended\n    event RewardEnded(address indexed dustReceiver, uint256 dust);\n    // Emitted when pool governor update reward end time\n    event UpdatedRewardEndTime(uint256 previousRewardEndTime, uint256 newRewardEndTime);\n\n    function claimReward(address) external;\n\n    function notifyRewardAmount(uint256 rewardAmount, uint256 endTime) external;\n\n    function updateRewardEndTime() external;\n\n    function updateReward(address) external;\n\n    function withdrawRemaining(address _toAddress) external;\n\n    function claimable(address) external view returns (uint256);\n\n    function lastTimeRewardApplicable() external view returns (uint256);\n\n    function rewardForDuration() external view returns (uint256);\n\n    function rewardPerToken() external view returns (uint256);\n\n    function rewardToken() external view returns (address);\n}\n"
    },
    "contracts/strategies/VesperV3StrategyUSDC.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"./VesperV3Strategy.sol\";\n\n//solhint-disable no-empty-blocks\ncontract VesperV3StrategyUSDC is VesperV3Strategy {\n    string public constant NAME = \"Strategy-VesperV3-USDC\";\n    string public constant VERSION = \"2.0.2\";\n\n    constructor(\n        address _controller,\n        address _pool,\n        address _receiptToken\n    ) public VesperV3Strategy(_controller, _pool, _receiptToken) {}\n}\n"
    },
    "contracts/strategies/VesperV3StrategyDAI.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"./VesperV3Strategy.sol\";\n\n//solhint-disable no-empty-blocks\ncontract VesperV3StrategyDAI is VesperV3Strategy {\n    string public constant NAME = \"Strategy-VesperV3-DAI\";\n    string public constant VERSION = \"2.0.9\";\n\n    constructor(\n        address _controller,\n        address _pool,\n        address _receiptToken\n    ) public VesperV3Strategy(_controller, _pool, _receiptToken) {}\n}\n"
    },
    "contracts/strategies/Crv3PoolStrategy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"../interfaces/vesper/IVesperPool.sol\";\nimport \"./Strategy.sol\";\nimport \"./Crv3PoolMgr.sol\";\n\n/// @title This strategy will deposit collateral token in Curve and earn interest.\nabstract contract Crv3PoolStrategy is Crv3PoolMgr, Strategy {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    mapping(address => bool) private reservedToken;\n    address[] private oracles;\n\n    uint256 public constant ORACLE_PERIOD = 3600; // 1h\n    uint256 public usdRate;\n    uint256 public usdRateTimestamp;\n    uint256 public immutable collIdx;\n\n    uint256 public prevLpRate;\n    uint256 public pendingFee;\n\n    uint256 public depositSlippage = 500; // 10000 is 100%\n    event UpdatedDepositSlippage(uint256 oldSlippage, uint256 newSlippage);\n\n    constructor(\n        address _controller,\n        address _pool,\n        uint256 _collateralIdx\n    ) public Strategy(_controller, _pool, THREECRV) Crv3PoolMgr() {\n        require(_collateralIdx < COINS.length, \"Invalid collateral for 3Pool\");\n        require(\n            COIN_ADDRS[_collateralIdx] == IVesperPool(_pool).token(),\n            \"Collateral does not match\"\n        );\n        reservedToken[THREECRV] = true;\n        reservedToken[COIN_ADDRS[_collateralIdx]] = true;\n        reservedToken[CRV] = true;\n        collIdx = _collateralIdx;\n        _setupOracles();\n    }\n\n    function updateDepositSlippage(uint256 _newSlippage) external onlyController {\n        require(_newSlippage != depositSlippage, \"same-slippage\");\n        require(_newSlippage < 10000, \"invalid-slippage-value\");\n        emit UpdatedDepositSlippage(depositSlippage, _newSlippage);\n        depositSlippage = _newSlippage;\n    }\n\n    function _setupOracles() internal {\n        oracles.push(swapManager.createOrUpdateOracle(CRV, WETH, ORACLE_PERIOD, 0));\n        for (uint256 i = 0; i < COIN_ADDRS.length; i++) {\n            oracles.push(swapManager.createOrUpdateOracle(COIN_ADDRS[i], WETH, ORACLE_PERIOD, 0));\n        }\n    }\n\n    function _estimateSlippage(uint256 _amount, uint256 _slippage) internal pure returns (uint256) {\n        return _amount.mul(10000 - _slippage).div(10000);\n    }\n\n    function _consultOracle(\n        address _from,\n        address _to,\n        uint256 _amt\n    ) internal returns (uint256, bool) {\n        // from, to, amountIn, period, router\n        uint256 rate;\n        uint256 lastUpdate;\n        (rate, lastUpdate, ) = swapManager.consult(_from, _to, _amt, ORACLE_PERIOD, 0);\n        // We're looking at a TWAP ORACLE with a 1 hr Period that has been updated within the last hour\n        if ((lastUpdate > (block.timestamp - ORACLE_PERIOD)) && (rate != 0)) return (rate, true);\n        return (0, false);\n    }\n\n    function _consultOracleFree(\n        address _from,\n        address _to,\n        uint256 _amt\n    ) internal view returns (uint256, bool) {\n        // from, to, amountIn, period, router\n        uint256 rate;\n        uint256 lastUpdate;\n        (rate, lastUpdate) = swapManager.consultForFree(_from, _to, _amt, ORACLE_PERIOD, 0);\n        // We're looking at a TWAP ORACLE with a 1 hr Period that has been updated within the last hour\n        if ((lastUpdate > (block.timestamp - ORACLE_PERIOD)) && (rate != 0)) return (rate, true);\n        return (0, false);\n    }\n\n    // given the rates of 3 stablecoins compared with a common denominator\n    // return the lowest divided by the highest\n    function _getSafeUsdRate() internal returns (uint256) {\n        // use a stored rate if we've looked it up recently\n        if (usdRateTimestamp > block.timestamp - ORACLE_PERIOD && usdRate != 0) return usdRate;\n        // otherwise, calculate a rate and store it.\n        uint256 lowest;\n        uint256 highest;\n        for (uint256 i = 0; i < COIN_ADDRS.length; i++) {\n            // get the rate for $1\n            (uint256 rate, bool isValid) = _consultOracle(COIN_ADDRS[i], WETH, 10**DECIMALS[i]);\n            if (isValid) {\n                if (lowest == 0 || rate < lowest) {\n                    lowest = rate;\n                }\n                if (highest < rate) {\n                    highest = rate;\n                }\n            }\n        }\n        // We only need to check one of them because if a single valid rate is returned,\n        // highest == lowest and highest > 0 && lowest > 0\n        require(lowest != 0, \"no-oracle-rates\");\n        usdRateTimestamp = block.timestamp;\n        usdRate = (lowest * 1e18) / highest;\n        return usdRate;\n    }\n\n    function _getSafeUsdRateFree() internal view returns (uint256) {\n        // use a stored rate if we've looked it up recently\n        if (usdRateTimestamp > block.timestamp - ORACLE_PERIOD && usdRate != 0) return usdRate;\n        // otherwise, calculate a rate and store it.\n        uint256 lowest;\n        uint256 highest;\n        for (uint256 i = 0; i < COIN_ADDRS.length; i++) {\n            // get the rate for $1\n            (uint256 rate, bool isValid) = _consultOracleFree(COIN_ADDRS[i], WETH, 10**DECIMALS[i]);\n            if (isValid) {\n                if (lowest == 0 || rate < lowest) {\n                    lowest = rate;\n                }\n                if (highest < rate) {\n                    highest = rate;\n                }\n            }\n        }\n        // We only need to check one of them because if a single valid rate is returned,\n        // highest == lowest and highest > 0 && lowest > 0\n        require(lowest != 0, \"no-oracle-rates\");\n        uint256 rate = (lowest * 1e18) / highest;\n        return rate;\n    }\n\n    function interestEarned() external view override returns (uint256 collAmt) {\n        uint256 crvAccrued = claimableRewards();\n        if (crvAccrued != 0) {\n            (, collAmt, ) = swapManager.bestOutputFixedInput(\n                CRV,\n                address(collateralToken),\n                crvAccrued\n            );\n        }\n        uint256 currentRate = _minimumLpPrice(_getSafeUsdRateFree());\n        if (currentRate > prevLpRate) {\n            collAmt = collAmt.add(\n                convertFrom18(totalLp().mul(currentRate.sub(prevLpRate)).div(1e18))\n            );\n        }\n    }\n\n    function _updatePendingFee() internal override {\n        uint256 currLpRate = _minimumLpPrice(_getSafeUsdRate());\n        if (prevLpRate != 0) {\n            if (currLpRate > prevLpRate) {\n                pendingFee = pendingFee.add(\n                    convertFrom18(\n                        currLpRate\n                            .sub(prevLpRate)\n                            .mul(totalLp())\n                            .mul(controller.interestFee(pool))\n                            .div(1e36)\n                    )\n                );\n            } else {\n                // don't take fees if we're not making money\n                return;\n            }\n        }\n        prevLpRate = currLpRate;\n    }\n\n    function rebalance() external override whenNotPaused {\n        // Check for LP appreciation and withdraw fees\n        _updatePendingFee();\n        uint256 fee = pendingFee;\n        // Get CRV rewards and convert to Collateral\n        // collect fees on profit from reward\n        _claimCrv();\n        uint256 earnedCollateral = _swapCrvToCollateral();\n        if (earnedCollateral != 0) {\n            fee = fee.add(earnedCollateral.mul(controller.interestFee(pool)).div(1e18));\n        }\n        if (fee != 0) {\n            if (fee > earnedCollateral) {\n                _unstakeAndWithdrawAsCollateral(fee.sub(earnedCollateral));\n            }\n            _handleFee(fee);\n            pendingFee = 0;\n        }\n        // make any relevant deposits\n        _deposit(collateralToken.balanceOf(pool));\n    }\n\n    /// Not needed for this strategy\n    // solhint-disable-next-line no-empty-blocks\n    function beforeWithdraw() external override {}\n\n    /// @dev Check whether given token is reserved or not. Reserved tokens are not allowed to sweep.\n    function isReservedToken(address _token) public view override returns (bool) {\n        return reservedToken[_token];\n    }\n\n    /// @notice Returns true if strategy can be upgraded.\n    /// @dev If there are no cTokens in strategy then it is upgradable\n    function isUpgradable() external view override returns (bool) {\n        return (totalLp() == 0) && (collateralToken.balanceOf(address(this)) == 0);\n    }\n\n    /// @dev Returns total collateral locked here\n    function totalLocked() public view override returns (uint256) {\n        return\n            collateralToken\n                .balanceOf(address(this))\n                .add(getLpValueAs(totalLp().add(IERC20(crvLp).balanceOf(pool)), collIdx))\n                .sub(pendingFee);\n    }\n\n    function _deposit(uint256 _amount) internal override {\n        // get deposits from pool\n        if (_amount != 0) {\n            collateralToken.safeTransferFrom(pool, address(this), _amount);\n        }\n        // if we have any collateral left here from other operations, that should go too\n        uint256[3] memory depositAmounts;\n        depositAmounts[collIdx] = collateralToken.balanceOf(address(this));\n        uint256 minLpAmount =\n            _estimateSlippage(\n                (depositAmounts[collIdx].mul(1e18)).div(_minimumLpPrice(_getSafeUsdRate())),\n                depositSlippage\n            );\n        THREEPOOL.add_liquidity(depositAmounts, minLpAmount);\n        _stakeAllLpToGauge();\n    }\n\n    function _withdraw(uint256 _amount) internal override {\n        _unstakeAndWithdrawAsCollateral(_amount);\n        collateralToken.safeTransfer(pool, IERC20(collateralToken).balanceOf(address(this)));\n    }\n\n    function _approveToken(uint256 _amount) internal override {\n        collateralToken.safeApprove(pool, _amount);\n        collateralToken.safeApprove(crvPool, _amount);\n        for (uint256 i = 0; i < swapManager.N_DEX(); i++) {\n            IERC20(CRV).safeApprove(address(swapManager.ROUTERS(i)), _amount);\n        }\n        IERC20(crvLp).safeApprove(crvGauge, _amount);\n    }\n\n    function _withdrawAll() internal override {\n        pendingFee = 0;\n        _unstakeAllLpFromGauge();\n        _withdrawAllAs(collIdx);\n        collateralToken.safeTransfer(pool, collateralToken.balanceOf(address(this)));\n    }\n\n    /// dev this function would only be a single line, so its omitted to save gas\n    // solhint-disable-next-line no-empty-blocks\n    function _claimReward() internal override {}\n\n    function _unstakeAndWithdrawAsCollateral(uint256 _amount) internal {\n        (uint256 lpToWithdraw, uint256 unstakeAmt) = calcWithdrawLpAs(_amount, collIdx);\n        _unstakeLpFromGauge(unstakeAmt);\n        uint256 minAmtOut =\n            (convertFrom18(_minimumLpPrice(_getSafeUsdRate())) * lpToWithdraw) / 1e18;\n\n        _withdrawAsFromCrvPool(lpToWithdraw, minAmtOut, collIdx);\n    }\n\n    function _swapCrvToCollateral() internal returns (uint256 collateralAmt) {\n        uint256 amt = IERC20(CRV).balanceOf(address(this));\n        if (amt != 0) {\n            (address[] memory path, uint256 amountOut, uint256 rIdx) =\n                swapManager.bestOutputFixedInput(CRV, address(collateralToken), amt);\n            if (amountOut != 0) {\n                collateralAmt = swapManager.ROUTERS(rIdx).swapExactTokensForTokens(\n                    amt,\n                    1,\n                    path,\n                    address(this),\n                    block.timestamp\n                )[path.length - 1];\n            }\n        }\n    }\n\n    function _migrateOut() internal override {\n        require(controller.isPool(pool), \"not-a-valid-pool\");\n        _pause();\n        pendingFee = 0;\n        _unstakeAllLpFromGauge();\n        IERC20(crvLp).safeTransfer(pool, IERC20(crvLp).balanceOf(address(this)));\n    }\n\n    function _migrateIn() internal override {\n        require(controller.isPool(pool), \"not-a-valid-pool\");\n        require(controller.strategy(pool) == address(this), \"not-a-valid-strategy\");\n        IERC20(crvLp).safeTransferFrom(pool, address(this), IERC20(crvLp).balanceOf(pool));\n    }\n}\n"
    },
    "contracts/strategies/Crv3PoolMgr.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"./CrvPoolMgrBase.sol\";\nimport \"../interfaces/curve/IStableSwap3Pool.sol\";\n\ncontract Crv3PoolMgr is CrvPoolMgrBase {\n    using SafeMath for uint256;\n\n    IStableSwap3Pool public constant THREEPOOL =\n        IStableSwap3Pool(0xbEbc44782C7dB0a1A60Cb6fe97d0b483032FF1C7);\n    address public constant THREECRV = 0x6c3F90f043a72FA612cbac8115EE7e52BDe6E490;\n    address public constant GAUGE = 0xbFcF63294aD7105dEa65aA58F8AE5BE2D9d0952A;\n\n    /* solhint-disable var-name-mixedcase */\n    string[3] public COINS = [\"DAI\", \"USDC\", \"USDT\"];\n\n    address[3] public COIN_ADDRS = [\n        0x6B175474E89094C44Da98b954EedeAC495271d0F, // DAI\n        0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48, // USDC\n        0xdAC17F958D2ee523a2206206994597C13D831ec7 // USDT\n    ];\n\n    uint256[3] public DECIMALS = [18, 6, 6];\n\n    /* solhint-enable */\n\n    // solhint-disable-next-line no-empty-blocks\n    constructor() public CrvPoolMgrBase(address(THREEPOOL), THREECRV, GAUGE) {}\n\n    function _minimumLpPrice(uint256 _safeRate) internal view returns (uint256) {\n        return ((THREEPOOL.get_virtual_price() * _safeRate) / 1e18);\n    }\n\n    function _depositToCrvPool(\n        uint256 _daiAmount,\n        uint256 _usdcAmount,\n        uint256 _usdtAmount\n    ) internal {\n        uint256[3] memory depositAmounts = [_daiAmount, _usdcAmount, _usdtAmount];\n        // using 1 for min_mint_amount, but we may want to improve this logic\n        THREEPOOL.add_liquidity(depositAmounts, 1);\n    }\n\n    function _depositDaiToCrvPool(uint256 _daiAmount, bool _stake) internal {\n        if (_daiAmount != 0) {\n            THREEPOOL.add_liquidity([_daiAmount, 0, 0], 1);\n            if (_stake) {\n                _stakeAllLpToGauge();\n            }\n        }\n    }\n\n    function _withdrawAsFromCrvPool(\n        uint256 _lpAmount,\n        uint256 _minAmt,\n        uint256 i\n    ) internal {\n        THREEPOOL.remove_liquidity_one_coin(_lpAmount, int128(i), _minAmt);\n    }\n\n    function _withdrawAllAs(uint256 i) internal {\n        uint256 lpAmt = IERC20(crvLp).balanceOf(address(this));\n        if (lpAmt != 0) {\n            THREEPOOL.remove_liquidity_one_coin(lpAmt, int128(i), 0);\n        }\n    }\n\n    function calcWithdrawLpAs(uint256 _amtNeeded, uint256 i)\n        public\n        view\n        returns (uint256 lpToWithdraw, uint256 unstakeAmt)\n    {\n        uint256 lp = IERC20(crvLp).balanceOf(address(this));\n        uint256 tlp = lp.add(IERC20(crvGauge).balanceOf(address(this)));\n        lpToWithdraw = _amtNeeded.mul(tlp).div(getLpValueAs(tlp, i));\n        lpToWithdraw = (lpToWithdraw > tlp) ? tlp : lpToWithdraw;\n        if (lpToWithdraw > lp) {\n            unstakeAmt = lpToWithdraw.sub(lp);\n        }\n    }\n\n    function getLpValueAs(uint256 _lpAmount, uint256 i) public view returns (uint256) {\n        return (_lpAmount != 0) ? THREEPOOL.calc_withdraw_one_coin(_lpAmount, int128(i)) : 0;\n    }\n\n    function estimateFeeImpact(uint256 _amount) public view returns (uint256) {\n        return _amount.mul(uint256(1e10).sub(estimatedFees())).div(1e10);\n    }\n\n    function estimatedFees() public view returns (uint256) {\n        return THREEPOOL.fee().mul(3);\n    }\n}\n"
    },
    "contracts/strategies/CrvPoolMgrBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"../interfaces/curve/ILiquidityGaugeV2.sol\";\nimport \"../interfaces/curve/ITokenMinter.sol\";\n\nabstract contract CrvPoolMgrBase {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    address public immutable crvPool;\n    address public immutable crvLp;\n    address public immutable crvGauge;\n    address public constant CRV_MINTER = 0xd061D61a4d941c39E5453435B6345Dc261C2fcE0;\n    address public constant CRV = 0xD533a949740bb3306d119CC777fa900bA034cd52;\n\n    constructor(\n        address _pool,\n        address _lp,\n        address _gauge\n    ) public {\n        require(_pool != address(0x0), \"CRVMgr: invalid curve pool\");\n        require(_lp != address(0x0), \"CRVMgr: invalid lp token\");\n        require(_gauge != address(0x0), \"CRVMgr: invalid gauge\");\n\n        crvPool = _pool;\n        crvLp = _lp;\n        crvGauge = _gauge;\n    }\n\n    // requires that gauge has approval for lp token\n    function _stakeAllLpToGauge() internal {\n        uint256 balance = IERC20(crvLp).balanceOf(address(this));\n        if (balance != 0) {\n            ILiquidityGaugeV2(crvGauge).deposit(balance);\n        }\n    }\n\n    function _unstakeAllLpFromGauge() internal {\n        _unstakeLpFromGauge(IERC20(crvGauge).balanceOf(address(this)));\n    }\n\n    function _unstakeLpFromGauge(uint256 _amount) internal {\n        if (_amount != 0) {\n            ILiquidityGaugeV2(crvGauge).withdraw(_amount);\n        }\n    }\n\n    function _claimCrv() internal {\n        ITokenMinter(CRV_MINTER).mint(crvGauge);\n    }\n\n    function _setCheckpoint() internal {\n        ILiquidityGaugeV2(crvGauge).user_checkpoint(address(this));\n    }\n\n    function claimableRewards() public view returns (uint256) {\n        //Total Mintable - Previously minted\n        return\n            ILiquidityGaugeV2(crvGauge).integrate_fraction(address(this)).sub(\n                ITokenMinter(CRV_MINTER).minted(address(this), crvGauge)\n            );\n    }\n\n    function totalLp() public view returns (uint256 total) {\n        total = IERC20(crvLp).balanceOf(address(this)).add(\n            IERC20(crvGauge).balanceOf(address(this))\n        );\n    }\n}\n"
    },
    "contracts/interfaces/curve/IStableSwap3Pool.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/* solhint-disable */\npragma solidity 0.6.12;\n\n// Not a complete interface, but should have what we need\ninterface IStableSwap3Pool {\n    function coins() external view returns (address[] memory);\n\n    function fee() external view returns (uint256); // fee * 1e10\n\n    function lp_token() external view returns (address);\n\n    function A() external view returns (uint256);\n\n    function A_precise() external view returns (uint256);\n\n    function balances(uint256 i) external view returns (uint256);\n\n    function get_virtual_price() external view returns (uint256);\n\n    function calc_token_amount(uint256[3] memory _amounts, bool is_deposit)\n        external\n        view\n        returns (uint256);\n\n    function add_liquidity(uint256[3] memory _amounts, uint256 _min_mint_amount) external;\n\n    function get_dy(\n        int128 i,\n        int128 j,\n        uint256 dx\n    ) external view returns (uint256);\n\n    function get_dy_underlying(\n        int128 i,\n        int128 j,\n        uint256 dx\n    ) external view returns (uint256);\n\n    function exchange(\n        int128 i,\n        int128 j,\n        uint256 dx,\n        uint256 min_dy\n    ) external returns (uint256);\n\n    function remove_liquidity(uint256 _amount, uint256[3] memory _min_amounts) external;\n\n    function remove_liquidity_imbalance(uint256[3] memory _amounts, uint256 _max_burn_amount)\n        external\n        returns (uint256);\n\n    function calc_withdraw_one_coin(uint256 _token_amount, int128 i)\n        external\n        view\n        returns (uint256);\n\n    function remove_liquidity_one_coin(\n        uint256 _token_amount,\n        int128 i,\n        uint256 _min_amount\n    ) external;\n}\n/* solhint-enable */\n"
    },
    "contracts/interfaces/curve/ILiquidityGaugeV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/* solhint-disable */\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n// Not a complete interface, but should have what we need\ninterface ILiquidityGaugeV2 is IERC20 {\n    function deposit(uint256 _value) external;\n\n    function withdraw(uint256 _value) external;\n\n    function claimable_tokens(address addr) external returns (uint256);\n\n    function integrate_fraction(address addr) external view returns (uint256);\n\n    function user_checkpoint(address addr) external returns (bool);\n}\n/* solhint-enable */\n"
    },
    "contracts/interfaces/curve/ITokenMinter.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/* solhint-disable */\npragma solidity 0.6.12;\n\n// Not a complete interface, but should have what we need\ninterface ITokenMinter {\n    function minted(address arg0, address arg1) external view returns (uint256);\n\n    function mint(address gauge_addr) external;\n}\n/* solhint-enable */\n"
    },
    "contracts/strategies/Crv3PoolStrategyUSDC.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"./Crv3PoolStrategy.sol\";\n\n//solhint-disable no-empty-blocks\ncontract Crv3PoolStrategyUSDC is Crv3PoolStrategy {\n    using SafeMath for uint256;\n\n    string public constant NAME = \"Strategy-Curve-3pool-USDC\";\n    string public constant VERSION = \"1.0.0\";\n\n    constructor(address _controller, address _pool)\n        public\n        Crv3PoolStrategy(_controller, _pool, 1)\n    {}\n\n    function convertFrom18(uint256 amount) public pure override returns (uint256) {\n        return amount.div(10**12);\n    }\n}\n"
    },
    "contracts/Timelock.sol": {
      "content": "// SPDX-License-Identifier: BSD 3-Clause\n\n// From https://github.com/compound-finance/compound-protocol/blob/master/contracts/Timelock.sol and modified as needed.\n\n// Copyright 2020 Compound Labs, Inc.\n// Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n// 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n// 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n// 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\n// solhint-disable reason-string\ncontract Timelock {\n    using SafeMath for uint256;\n\n    event NewAdmin(address indexed newAdmin);\n    event NewPendingAdmin(address indexed newPendingAdmin);\n    event NewDelay(uint256 indexed newDelay);\n    event CancelTransaction(\n        bytes32 indexed txHash,\n        address indexed target,\n        uint256 value,\n        string signature,\n        bytes data,\n        uint256 eta\n    );\n    event ExecuteTransaction(\n        bytes32 indexed txHash,\n        address indexed target,\n        uint256 value,\n        string signature,\n        bytes data,\n        uint256 eta\n    );\n    event QueueTransaction(\n        bytes32 indexed txHash,\n        address indexed target,\n        uint256 value,\n        string signature,\n        bytes data,\n        uint256 eta\n    );\n\n    uint256 public constant GRACE_PERIOD = 14 days;\n    uint256 public constant MINIMUM_DELAY = 2 days;\n    uint256 public constant MAXIMUM_DELAY = 30 days;\n\n    address public admin;\n    address public pendingAdmin;\n    uint256 public delay;\n\n    mapping(bytes32 => bool) public queuedTransactions;\n\n    constructor(address admin_, uint256 delay_) public {\n        require(admin_ != address(0), \"Timelock::constructor: Admin must be valid address\");\n        require(delay_ >= MINIMUM_DELAY, \"Timelock::constructor: Delay must exceed minimum delay.\");\n        require(\n            delay_ <= MAXIMUM_DELAY,\n            \"Timelock::constructor: Delay must not exceed maximum delay.\"\n        );\n\n        admin = admin_;\n        delay = delay_;\n    }\n\n    // solhint-disable no-empty-blocks\n    receive() external payable {}\n\n    function setDelay(uint256 delay_) public {\n        require(msg.sender == address(this), \"Timelock::setDelay: Call must come from Timelock.\");\n        require(delay_ >= MINIMUM_DELAY, \"Timelock::setDelay: Delay must exceed minimum delay.\");\n        require(\n            delay_ <= MAXIMUM_DELAY,\n            \"Timelock::setDelay: Delay must not exceed maximum delay.\"\n        );\n        delay = delay_;\n\n        emit NewDelay(delay);\n    }\n\n    function acceptAdmin() public {\n        require(\n            msg.sender == pendingAdmin,\n            \"Timelock::acceptAdmin: Call must come from pendingAdmin.\"\n        );\n        admin = msg.sender;\n        pendingAdmin = address(0);\n\n        emit NewAdmin(admin);\n    }\n\n    function setPendingAdmin(address pendingAdmin_) public {\n        require(\n            msg.sender == address(this),\n            \"Timelock::setPendingAdmin: Call must come from Timelock.\"\n        );\n        pendingAdmin = pendingAdmin_;\n\n        emit NewPendingAdmin(pendingAdmin);\n    }\n\n    function queueTransaction(\n        address target,\n        uint256 value,\n        string memory signature,\n        bytes memory data,\n        uint256 eta\n    ) public returns (bytes32) {\n        require(msg.sender == admin, \"Timelock::queueTransaction: Call must come from admin.\");\n        require(\n            eta >= getBlockTimestamp().add(delay),\n            \"Timelock::queueTransaction: Estimated execution block must satisfy delay.\"\n        );\n\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n        queuedTransactions[txHash] = true;\n\n        emit QueueTransaction(txHash, target, value, signature, data, eta);\n        return txHash;\n    }\n\n    function cancelTransaction(\n        address target,\n        uint256 value,\n        string memory signature,\n        bytes memory data,\n        uint256 eta\n    ) public {\n        require(msg.sender == admin, \"Timelock::cancelTransaction: Call must come from admin.\");\n\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n        queuedTransactions[txHash] = false;\n\n        emit CancelTransaction(txHash, target, value, signature, data, eta);\n    }\n\n    function executeTransaction(\n        address target,\n        uint256 value,\n        string memory signature,\n        bytes memory data,\n        uint256 eta\n    ) public payable returns (bytes memory) {\n        require(msg.sender == admin, \"Timelock::executeTransaction: Call must come from admin.\");\n\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n        require(\n            queuedTransactions[txHash],\n            \"Timelock::executeTransaction: Transaction hasn't been queued.\"\n        );\n        require(\n            getBlockTimestamp() >= eta,\n            \"Timelock::executeTransaction: Transaction hasn't surpassed time lock.\"\n        );\n        require(\n            getBlockTimestamp() <= eta.add(GRACE_PERIOD),\n            \"Timelock::executeTransaction: Transaction is stale.\"\n        );\n\n        queuedTransactions[txHash] = false;\n\n        bytes memory callData;\n\n        if (bytes(signature).length == 0) {\n            callData = data;\n        } else {\n            callData = abi.encodePacked(bytes4(keccak256(bytes(signature))), data);\n        }\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returnData) = target.call{value: value}(callData);\n        require(success, \"Timelock::executeTransaction: Transaction execution reverted.\");\n\n        emit ExecuteTransaction(txHash, target, value, signature, data, eta);\n\n        return returnData;\n    }\n\n    function getBlockTimestamp() internal view returns (uint256) {\n        return block.timestamp;\n    }\n}\n"
    },
    "contracts/strategies/PaymentSplitter.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/GSN/Context.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n\n/**\n * @title PaymentSplitter\n * @dev This contract allows to split ERC20 and Ether tokens among a group of accounts. The sender does not need to be aware\n * that the token(s) (payment) will be split in this way, since it is handled transparently by the contract.\n *\n * The split can be in equal parts or in any other arbitrary proportion. The way this is specified is by assigning each\n * account to a number of shares. Of all the payment(s) that this contract receives, each account will then be able to claim\n * an amount proportional to the percentage of total shares they were assigned.\n *\n * `PaymentSplitter` follows a _pull payment_ model. This means that payments are not automatically forwarded to the\n * accounts but kept in this contract, and the actual transfer is triggered as a separate step by calling the {release} or {releaseEther}\n * function.\n */\ncontract PaymentSplitter is Context {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n    event PayeeAdded(address indexed payee, uint256 share);\n    event PaymentReleased(address indexed payee, address indexed asset, uint256 tokens);\n\n    // Total share.\n    uint256 public totalShare;\n    // Total released for an asset.\n    mapping(address => uint256) public totalReleased;\n    // Payee's share\n    mapping(address => uint256) public share;\n    // Payee's share released for an asset\n    mapping(address => mapping(address => uint256)) public released;\n    // list of payees\n    address[] public payees;\n    address public veth;\n    address private constant ETHER_ASSET = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n    address private constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n    address private constant VESPER_DEPLOYER = 0xB5AbDABE50b5193d4dB92a16011792B22bA3Ef51;\n    uint256 public constant HIGH = 20e18; // 20 Ether\n    uint256 public constant LOW = 5e18; // 5 Ether\n\n    /**\n     * @dev Creates an instance of `PaymentSplitter` where each account in `_payees` is assigned token(s) at\n     * the matching position in the `_share` array.\n     *\n     * All addresses in `payees` must be non-zero. Both arrays must have the same non-zero length, and there must be no\n     * duplicates in `payees`.\n     * @param _payees -  address(es) of payees eligible to receive token(s)\n     * @param _share - list of shares, transferred to payee in provided ratio.\n     * @param _veth - vETH address, used for vesper deployer top up\n     */\n    constructor(\n        address[] memory _payees,\n        uint256[] memory _share,\n        address _veth\n    ) public {\n        // solhint-disable-next-line max-line-length\n        require(_payees.length == _share.length, \"payees-and-share-length-mismatch\");\n        require(_payees.length > 0, \"no-payees\");\n        require(_veth != address(0), \"invalid-veth\");\n        veth = _veth;\n\n        for (uint256 i = 0; i < _payees.length; i++) {\n            _addPayee(_payees[i], _share[i]);\n        }\n    }\n\n    //solhint-disable no-empty-blocks\n    receive() external payable {}\n\n    /**\n     * @dev Transfer of ERC20 token(s) to `payee` based on share and their previous withdrawals.\n     * @param _payee - payee's address to receive token(s)\n     * @param _asset - ERC20 token's address\n     */\n    function release(address _payee, address _asset) external {\n        require(share[_payee] > 0, \"payee-does-not-have-share\");\n        _topUp();\n        uint256 totalReceived = IERC20(_asset).balanceOf(address(this)).add(totalReleased[_asset]);\n        uint256 tokens = _calculateAndUpdateReleasedTokens(_payee, _asset, totalReceived);\n        IERC20(_asset).safeTransfer(_payee, tokens);\n        emit PaymentReleased(_payee, _asset, tokens);\n    }\n\n    /**\n     * @dev Transfer of ether to `payee` based on share and their previous withdrawals.\n     * @param _payee - payee's address to receive ether\n     */\n    function releaseEther(address payable _payee) external {\n        require(share[_payee] > 0, \"payee-does-not-have-share\");\n        uint256 totalReceived = address(this).balance.add(totalReleased[ETHER_ASSET]);\n        // find total received amount\n        uint256 amount = _calculateAndUpdateReleasedTokens(_payee, ETHER_ASSET, totalReceived);\n        // Transfer Ether to Payee.\n        Address.sendValue(_payee, amount);\n        emit PaymentReleased(_payee, ETHER_ASSET, amount);\n    }\n\n    /// @notice Top up Vesper deployer address\n    function topUp() external {\n        _topUp();\n    }\n\n    /// @dev Top up Vesper deployer address when balance goes below low mark.\n    function _topUp() internal {\n        uint256 totalEthBalance =\n            VESPER_DEPLOYER.balance.add(IERC20(WETH).balanceOf(VESPER_DEPLOYER)).add(\n                IERC20(veth).balanceOf(VESPER_DEPLOYER)\n            );\n        // transfer only when balance is < low mark\n        if (totalEthBalance < LOW) {\n            uint256 amount =\n                IERC20(veth).balanceOf(address(this)) > (HIGH.sub(totalEthBalance))\n                    ? (HIGH.sub(totalEthBalance))\n                    : IERC20(veth).balanceOf(address(this));\n            IERC20(veth).safeTransfer(VESPER_DEPLOYER, amount);\n        }\n    }\n\n    /**\n     * @dev Calculate token(s) for `payee` based on share and their previous withdrawals.\n     * @param _payee - payee's address\n     * @param _asset - token's address\n     * return token(s)/ ether to be released\n     */\n    function _calculateAndUpdateReleasedTokens(\n        address _payee,\n        address _asset,\n        uint256 _totalReceived\n    ) private returns (uint256 tokens) {\n        // find eligible token(s)/ether for a payee\n        uint256 releasedTokens = released[_payee][_asset];\n        tokens = _totalReceived.mul(share[_payee]).div(totalShare).sub(releasedTokens);\n        require(tokens != 0, \"payee-is-not-due-for-tokens\");\n        // update released token(s)\n        released[_payee][_asset] = releasedTokens.add(tokens);\n        totalReleased[_asset] = totalReleased[_asset].add(tokens);\n    }\n\n    /**\n     * @dev Add a new payee to the contract.\n     * @param _payee - payee address\n     * @param _share -  payee's share\n     */\n    function _addPayee(address _payee, uint256 _share) private {\n        require(_payee != address(0), \"payee-is-zero-address\");\n        require(_share > 0, \"payee-with-zero-share\");\n        require(share[_payee] == 0, \"payee-exists-with-share\");\n        payees.push(_payee);\n        share[_payee] = _share;\n        totalShare = totalShare.add(_share);\n        emit PayeeAdded(_payee, _share);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../../utils/Context.sol\";\nimport \"./IERC20.sol\";\nimport \"../../math/SafeMath.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20 {\n    using SafeMath for uint256;\n\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\n     * a default value of 18.\n     *\n     * To select a different value for {decimals}, use {_setupDecimals}.\n     *\n     * All three of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor (string memory name_, string memory symbol_) public {\n        _name = name_;\n        _symbol = symbol_;\n        _decimals = 18;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\n     * called.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual returns (uint8) {\n        return _decimals;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\n        _totalSupply = _totalSupply.sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Sets {decimals} to a value other than the default one of 18.\n     *\n     * WARNING: This function should only be called from the constructor. Most\n     * applications that interact with token contracts will not expect\n     * {decimals} to ever change, and may work incorrectly if it does.\n     */\n    function _setupDecimals(uint8 decimals_) internal virtual {\n        _decimals = decimals_;\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be to transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\n}\n"
    },
    "contracts/test/ITokenTest.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ninterface TokenLikeTest is IERC20 {\n    function deposit() external payable;\n\n    function withdraw(uint256) external;\n\n    function decimals() external view returns (uint256);\n}\n"
    },
    "contracts/governor/VSPGovernanceToken.sol": {
      "content": "// SPDX-License-Identifier: BSD 3-Clause\n\n// From https://github.com/compound-finance/compound-protocol/blob/master/contracts/Governance/Comp.sol\n\n// Copyright 2020 Compound Labs, Inc.\n// Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n// 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n// 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n// 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\n// solhint-disable reason-string, no-empty-blocks\nabstract contract VSPGovernanceToken is ERC20 {\n    /// @dev A record of each accounts delegate\n    mapping(address => address) public delegates;\n\n    /// @dev A checkpoint for marking number of votes from a given block\n    struct Checkpoint {\n        uint32 fromBlock;\n        uint256 votes;\n    }\n\n    /// @dev A record of votes checkpoints for each account, by index\n    mapping(address => mapping(uint32 => Checkpoint)) public checkpoints;\n\n    /// @dev The number of checkpoints for each account\n    mapping(address => uint32) public numCheckpoints;\n\n    /// @dev The EIP-712 typehash for the contract's domain\n    bytes32 public constant DOMAIN_TYPEHASH =\n        keccak256(\n            \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n        );\n\n    /// @dev The EIP-712 typehash for the delegation struct used by the contract\n    bytes32 public constant DELEGATION_TYPEHASH =\n        keccak256(\"Delegation(address delegatee,uint256 nonce,uint256 expiry)\");\n\n    /// @dev A record of states for signing / validating signatures\n    mapping(address => uint256) public nonces;\n\n    /// @dev An event thats emitted when an account changes its delegate\n    event DelegateChanged(\n        address indexed delegator,\n        address indexed fromDelegate,\n        address indexed toDelegate\n    );\n\n    /// @dev An event thats emitted when a delegate account's vote balance changes\n    event DelegateVotesChanged(\n        address indexed delegate,\n        uint256 previousBalance,\n        uint256 newBalance\n    );\n\n    /**\n     * @dev Constructor.\n     */\n    constructor(string memory name, string memory symbol) public ERC20(name, symbol) {}\n\n    /**\n     * @dev Delegate votes from `msg.sender` to `delegatee`\n     * @param delegatee The address to delegate votes to\n     */\n    function delegate(address delegatee) external {\n        return _delegate(msg.sender, delegatee);\n    }\n\n    /**\n     * @dev Delegates votes from signatory to `delegatee`\n     * @param delegatee The address to delegate votes to\n     * @param nonce The contract state required to match the signature\n     * @param expiry The time at which to expire the signature\n     * @param v The recovery byte of the signature\n     * @param r Half of the ECDSA signature pair\n     * @param s Half of the ECDSA signature pair\n     */\n    function delegateBySig(\n        address delegatee,\n        uint256 nonce,\n        uint256 expiry,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external {\n        bytes32 domainSeparator =\n            keccak256(\n                abi.encode(\n                    DOMAIN_TYPEHASH,\n                    keccak256(bytes(name())),\n                    keccak256(bytes(\"1\")),\n                    getChainId(),\n                    address(this)\n                )\n            );\n\n        bytes32 structHash = keccak256(abi.encode(DELEGATION_TYPEHASH, delegatee, nonce, expiry));\n\n        bytes32 digest = keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n\n        address signatory = ecrecover(digest, v, r, s);\n        require(signatory != address(0), \"VSP::delegateBySig: invalid signature\");\n        require(nonce == nonces[signatory]++, \"VSP::delegateBySig: invalid nonce\");\n        require(now <= expiry, \"VSP::delegateBySig: signature expired\");\n        return _delegate(signatory, delegatee);\n    }\n\n    /**\n     * @dev Gets the current votes balance for `account`\n     * @param account The address to get votes balance\n     * @return The number of current votes for `account`\n     */\n    function getCurrentVotes(address account) external view returns (uint256) {\n        uint32 nCheckpoints = numCheckpoints[account];\n        return nCheckpoints > 0 ? checkpoints[account][nCheckpoints - 1].votes : 0;\n    }\n\n    /**\n     * @dev Determine the prior number of votes for an account as of a block number\n     * @dev Block number must be a finalized block or else this function will revert to prevent misinformation.\n     * @param account The address of the account to check\n     * @param blockNumber The block number to get the vote balance at\n     * @return The number of votes the account had as of the given block\n     */\n    function getPriorVotes(address account, uint256 blockNumber) external view returns (uint256) {\n        require(blockNumber < block.number, \"VSP::getPriorVotes: not yet determined\");\n\n        uint32 nCheckpoints = numCheckpoints[account];\n        if (nCheckpoints == 0) {\n            return 0;\n        }\n\n        // First check most recent balance\n        if (checkpoints[account][nCheckpoints - 1].fromBlock <= blockNumber) {\n            return checkpoints[account][nCheckpoints - 1].votes;\n        }\n\n        // Next check implicit zero balance\n        if (checkpoints[account][0].fromBlock > blockNumber) {\n            return 0;\n        }\n\n        uint32 lower = 0;\n        uint32 upper = nCheckpoints - 1;\n        while (upper > lower) {\n            uint32 center = upper - (upper - lower) / 2; // ceil, avoiding overflow\n            Checkpoint memory cp = checkpoints[account][center];\n            if (cp.fromBlock == blockNumber) {\n                return cp.votes;\n            } else if (cp.fromBlock < blockNumber) {\n                lower = center;\n            } else {\n                upper = center - 1;\n            }\n        }\n        return checkpoints[account][lower].votes;\n    }\n\n    function _delegate(address delegator, address delegatee) internal {\n        address currentDelegate = delegates[delegator];\n        uint256 delegatorBalance = balanceOf(delegator);\n        delegates[delegator] = delegatee;\n\n        emit DelegateChanged(delegator, currentDelegate, delegatee);\n\n        _moveDelegates(currentDelegate, delegatee, delegatorBalance);\n    }\n\n    function _moveDelegates(\n        address srcRep,\n        address dstRep,\n        uint256 amount\n    ) internal {\n        if (srcRep != dstRep && amount > 0) {\n            if (srcRep != address(0)) {\n                // decrease old representative\n                uint32 srcRepNum = numCheckpoints[srcRep];\n                uint256 srcRepOld = srcRepNum > 0 ? checkpoints[srcRep][srcRepNum - 1].votes : 0;\n                uint256 srcRepNew = srcRepOld.sub(amount);\n                _writeCheckpoint(srcRep, srcRepNum, srcRepOld, srcRepNew);\n            }\n\n            if (dstRep != address(0)) {\n                // increase new representative\n                uint32 dstRepNum = numCheckpoints[dstRep];\n                uint256 dstRepOld = dstRepNum > 0 ? checkpoints[dstRep][dstRepNum - 1].votes : 0;\n                uint256 dstRepNew = dstRepOld.add(amount);\n                _writeCheckpoint(dstRep, dstRepNum, dstRepOld, dstRepNew);\n            }\n        }\n    }\n\n    function _writeCheckpoint(\n        address delegatee,\n        uint32 nCheckpoints,\n        uint256 oldVotes,\n        uint256 newVotes\n    ) internal {\n        uint32 blockNumber =\n            safe32(block.number, \"VSP::_writeCheckpoint: block number exceeds 32 bits\");\n\n        if (nCheckpoints > 0 && checkpoints[delegatee][nCheckpoints - 1].fromBlock == blockNumber) {\n            checkpoints[delegatee][nCheckpoints - 1].votes = newVotes;\n        } else {\n            checkpoints[delegatee][nCheckpoints] = Checkpoint(blockNumber, newVotes);\n            numCheckpoints[delegatee] = nCheckpoints + 1;\n        }\n\n        emit DelegateVotesChanged(delegatee, oldVotes, newVotes);\n    }\n\n    function safe32(uint256 n, string memory errorMessage) internal pure returns (uint32) {\n        require(n < 2**32, errorMessage);\n        return uint32(n);\n    }\n\n    function getChainId() internal pure returns (uint256) {\n        uint256 chainId;\n        assembly {\n            chainId := chainid()\n        }\n        return chainId;\n    }\n}\n"
    },
    "contracts/governor/VSP.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"../Owned.sol\";\nimport \"./VSPGovernanceToken.sol\";\n\n// solhint-disable no-empty-blocks\ncontract VSP is VSPGovernanceToken, Owned {\n    /// @dev The EIP-712 typehash for the permit struct used by the contract\n    bytes32 public constant PERMIT_TYPEHASH =\n        keccak256(\n            \"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\"\n        );\n\n    uint256 internal immutable mintLockPeriod;\n    uint256 internal constant INITIAL_MINT_LIMIT = 10000000 * (10**18);\n\n    constructor() public VSPGovernanceToken(\"VesperToken\", \"VSP\") {\n        mintLockPeriod = block.timestamp + (365 days);\n    }\n\n    /// @dev Mint VSP. Only owner can mint\n    function mint(address _recipient, uint256 _amount) external onlyOwner {\n        require(\n            (totalSupply().add(_amount) <= INITIAL_MINT_LIMIT) ||\n                (block.timestamp > mintLockPeriod),\n            \"Minting not allowed\"\n        );\n        _mint(_recipient, _amount);\n        _moveDelegates(address(0), delegates[_recipient], _amount);\n    }\n\n    /// @dev Burn VSP from caller\n    function burn(uint256 _amount) external {\n        _burn(_msgSender(), _amount);\n        _moveDelegates(delegates[_msgSender()], address(0), _amount);\n    }\n\n    /// @dev Burn VSP from given account. Caller must have proper allowance.\n    function burnFrom(address _account, uint256 _amount) external {\n        uint256 decreasedAllowance =\n            allowance(_account, _msgSender()).sub(_amount, \"ERC20: burn amount exceeds allowance\");\n\n        _approve(_account, _msgSender(), decreasedAllowance);\n        _burn(_account, _amount);\n        _moveDelegates(delegates[_account], address(0), _amount);\n    }\n\n    /**\n     * @notice Transfer tokens to multiple recipient\n     * @dev Left 160 bits are the recipient address and the right 96 bits are the token amount.\n     * @param bits array of uint\n     * @return true/false\n     */\n    function multiTransfer(uint256[] memory bits) external returns (bool) {\n        for (uint256 i = 0; i < bits.length; i++) {\n            address a = address(bits[i] >> 96);\n            uint256 amount = bits[i] & ((1 << 96) - 1);\n            require(transfer(a, amount), \"Transfer failed\");\n        }\n        return true;\n    }\n\n    /**\n     * @notice Triggers an approval from owner to spends\n     * @param _owner The address to approve from\n     * @param _spender The address to be approved\n     * @param _amount The number of tokens that are approved (2^256-1 means infinite)\n     * @param _deadline The time at which to expire the signature\n     * @param _v The recovery byte of the signature\n     * @param _r Half of the ECDSA signature pair\n     * @param _s Half of the ECDSA signature pair\n     */\n    function permit(\n        address _owner,\n        address _spender,\n        uint256 _amount,\n        uint256 _deadline,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    ) external {\n        require(_deadline >= block.timestamp, \"VSP:permit: signature expired\");\n\n        bytes32 domainSeparator =\n            keccak256(\n                abi.encode(\n                    DOMAIN_TYPEHASH,\n                    keccak256(bytes(name())),\n                    keccak256(bytes(\"1\")),\n                    getChainId(),\n                    address(this)\n                )\n            );\n        bytes32 structHash =\n            keccak256(\n                abi.encode(PERMIT_TYPEHASH, _owner, _spender, _amount, nonces[_owner]++, _deadline)\n            );\n        bytes32 digest = keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n        address signatory = ecrecover(digest, _v, _r, _s);\n        require(signatory != address(0) && signatory == _owner, \"VSP::permit: invalid signature\");\n        _approve(_owner, _spender, _amount);\n    }\n\n    /// @dev Overridden ERC20 transfer\n    function transfer(address recipient, uint256 amount) public override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        _moveDelegates(delegates[_msgSender()], delegates[recipient], amount);\n        return true;\n    }\n\n    /// @dev Overridden ERC20 transferFrom\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(\n            sender,\n            _msgSender(),\n            allowance(sender, _msgSender()).sub(\n                amount,\n                \"VSP::transferFrom: transfer amount exceeds allowance\"\n            )\n        );\n        _moveDelegates(delegates[sender], delegates[recipient], amount);\n        return true;\n    }\n}\n"
    },
    "contracts/strategies/CompoundStrategy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"./Strategy.sol\";\nimport \"../interfaces/compound/ICompound.sol\";\nimport \"../interfaces/vesper/IVesperPool.sol\";\n\n/// @title This strategy will deposit collateral token in Compound and earn interest.\nabstract contract CompoundStrategy is Strategy {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    uint256 public pendingFee;\n\n    CToken internal immutable cToken;\n    address internal immutable rewardToken;\n    Comptroller internal immutable comptroller;\n    uint256 internal exchangeRateStored;\n\n    constructor(\n        address _controller,\n        address _pool,\n        address _receiptToken,\n        address _rewardToken,\n        address _comptroller\n    ) public Strategy(_controller, _pool, _receiptToken) {\n        require(_rewardToken != address(0), \"RewardToken address is zero\");\n        cToken = CToken(_receiptToken);\n        rewardToken = _rewardToken;\n        comptroller = Comptroller(_comptroller);\n    }\n\n    /// @notice Vesper pools are using this function so it should exist in all strategies.\n    //solhint-disable-next-line no-empty-blocks\n    function beforeWithdraw() external override onlyPool {}\n\n    /**\n     * @dev Calculate interest fee on earning from Compound and transfer fee to fee collector.\n     * Deposit available collateral from pool into Compound.\n     * Anyone can call it except when paused.\n     */\n    function rebalance() external override onlyKeeper {\n        _rebalanceEarned();\n        uint256 balance = collateralToken.balanceOf(pool);\n        if (balance != 0) {\n            _deposit(balance);\n        }\n    }\n\n    /// @notice Returns true if strategy can be upgraded.\n    /// @dev If there are no cTokens in strategy then it is upgradable\n    function isUpgradable() external view override returns (bool) {\n        return cToken.balanceOf(address(this)) == 0;\n    }\n\n    /**\n     * @notice Returns interest earned in COMP since last rebalance.\n     * @dev Make sure to return value in collateral token\n     */\n    function interestEarned() public view override returns (uint256 collateralEarned) {\n        uint256 compAccrued = comptroller.compAccrued(address(this));\n        if (compAccrued != 0) {\n            (, collateralEarned, ) = swapManager.bestOutputFixedInput(\n                rewardToken,\n                address(collateralToken),\n                compAccrued\n            );\n        }\n    }\n\n    /// @notice This method is deprecated and will be removed from Strategies in next release\n    function isReservedToken(address _token) public view override returns (bool) {\n        return _token == address(cToken) || _token == rewardToken;\n    }\n\n    /**\n     * @notice Total collateral locked in Compound.\n     * @dev This value will be used in pool share calculation, so true totalLocked\n     * will be balance in Compound minus any pending fee to collect.\n     * @return Return value will be in collateralToken defined decimal.\n     */\n    function totalLocked() public view override returns (uint256) {\n        uint256 _totalCTokens = cToken.balanceOf(pool).add(cToken.balanceOf(address(this)));\n        return _convertToCollateral(_totalCTokens).sub(_calculatePendingFee());\n    }\n\n    function _approveToken(uint256 _amount) internal override {\n        collateralToken.safeApprove(pool, _amount);\n        collateralToken.safeApprove(address(cToken), _amount);\n        for (uint256 i = 0; i < swapManager.N_DEX(); i++) {\n            IERC20(rewardToken).safeApprove(address(swapManager.ROUTERS(i)), _amount);\n        }\n    }\n\n    /**\n     * @dev Claim rewardToken and convert rewardToken into collateral token.\n     * Calculate interest fee on earning from rewardToken and transfer balance minus\n     * fee to pool.\n     * @dev Transferring collateral to pool will increase pool share price.\n     */\n    function _claimReward() internal override {\n        address[] memory markets = new address[](1);\n        markets[0] = address(cToken);\n        comptroller.claimComp(address(this), markets);\n\n        uint256 _rewardAmount = IERC20(rewardToken).balanceOf(address(this));\n        if (_rewardAmount > 0) {\n            _safeSwap(rewardToken, address(collateralToken), _rewardAmount);\n            uint256 _collateralEarned = collateralToken.balanceOf(address(this));\n            uint256 _fee = _collateralEarned.mul(controller.interestFee(pool)).div(1e18);\n            collateralToken.safeTransfer(pool, _collateralEarned.sub(_fee));\n        }\n    }\n\n    function _deposit(uint256 _amount) internal virtual override {\n        collateralToken.safeTransferFrom(pool, address(this), _amount);\n        require(cToken.mint(_amount) == 0, \"deposit-failed\");\n    }\n\n    /**\n     * @notice Migrate tokens from pool to this address\n     * @dev Any working Compound strategy has cTokens in strategy contract.\n     * @dev There can be scenarios when pool already has cTokens and new\n     * strategy will have to move those tokens from pool to self address.\n     * @dev Only valid pool strategy is allowed to move tokens from pool.\n     */\n    function _migrateIn() internal override {\n        require(controller.isPool(pool), \"not-a-valid-pool\");\n        require(controller.strategy(pool) == address(this), \"not-a-valid-strategy\");\n        IERC20(cToken).safeTransferFrom(pool, address(this), cToken.balanceOf(pool));\n    }\n\n    /**\n     * @notice Migrate tokens out to pool.\n     * @dev There can be scenarios when we want to use new strategy without\n     * calling withdrawAll(). We can achieve this by moving tokens in pool\n     * and new strategy will take care from there.\n     * @dev Pause this strategy, set pendingFee to zero and move tokens out.\n     */\n    function _migrateOut() internal override {\n        require(controller.isPool(pool), \"not-a-valid-pool\");\n        _pause();\n        pendingFee = 0;\n        IERC20(cToken).safeTransfer(pool, cToken.balanceOf(address(this)));\n    }\n\n    /**\n     * @dev Calculate interest fee earning and transfer it to fee collector.\n     * RebalanceEarned completes in following steps,\n     *      Claim rewardToken and earn fee.\n     *      Update pending fee.\n     *      Withdraw collateral equal to pendingFee from compound.\n     *      Now we have collateral equal to pendingFee + fee earning from rewardToken.\n     *      Deposit collateral in Pool and get shares.\n     *      Transfer shares to feeCollector.\n     */\n    function _rebalanceEarned() internal {\n        _claimReward();\n        _updatePendingFee();\n        // Read state variable once to save gas\n        uint256 _pendingFee = pendingFee;\n        uint256 _cTokenAmount = _convertToCToken(_pendingFee);\n        if (_cTokenAmount != 0) {\n            require(cToken.redeemUnderlying(_pendingFee) == 0, \"rebalanceEarned::withdraw-failed\");\n            // Update state variable\n            pendingFee = 0;\n            _afterRedeem();\n        }\n        _handleFee(collateralToken.balanceOf(address(this)));\n    }\n\n    function _withdraw(uint256 _amount) internal override {\n        require(cToken.redeemUnderlying(_amount) == 0, \"withdraw-failed\");\n        _afterRedeem();\n        collateralToken.safeTransfer(pool, collateralToken.balanceOf(address(this)));\n    }\n\n    function _withdrawAll() internal override {\n        pendingFee = 0;\n        require(cToken.redeem(cToken.balanceOf(address(this))) == 0, \"withdraw-all-failed\");\n        _afterRedeem();\n        collateralToken.safeTransfer(pool, collateralToken.balanceOf(address(this)));\n    }\n\n    /// @dev Hook to call after collateral is redeemed from Compound\n    /// @notice We did empty implementation as not all derived are going to implement it.\n    //solhint-disable-next-line no-empty-blocks\n    function _afterRedeem() internal virtual {}\n\n    function _convertToCToken(uint256 _collateralAmount) internal view returns (uint256) {\n        return _collateralAmount.mul(1e18).div(cToken.exchangeRateStored());\n    }\n\n    function _convertToCollateral(uint256 _cTokenAmount) internal view returns (uint256) {\n        return _cTokenAmount.mul(cToken.exchangeRateStored()).div(1e18);\n    }\n\n    function _calculatePendingFee() internal view returns (uint256) {\n        uint256 interest =\n            cToken\n                .exchangeRateStored()\n                .sub(exchangeRateStored)\n                .mul(cToken.balanceOf(address(this)))\n                .div(1e18);\n        uint256 fee = interest.mul(controller.interestFee(pool)).div(1e18);\n        return pendingFee.add(fee);\n    }\n\n    function _updatePendingFee() internal override {\n        pendingFee = _calculatePendingFee();\n        exchangeRateStored = cToken.exchangeRateStored();\n    }\n}\n"
    },
    "contracts/interfaces/compound/ICompound.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface CToken is IERC20 {\n    function accrueInterest() external returns (uint256);\n\n    function balanceOfUnderlying(address owner) external returns (uint256);\n\n    function exchangeRateCurrent() external returns (uint256);\n\n    function exchangeRateStored() external view returns (uint256);\n\n    function mint() external payable; // For ETH\n\n    function mint(uint256 mintAmount) external returns (uint256); // For ERC20\n\n    function redeem(uint256 redeemTokens) external returns (uint256);\n\n    function redeemUnderlying(uint256 redeemAmount) external returns (uint256);\n}\n\ninterface Comptroller {\n    function claimComp(address holder, address[] memory) external;\n\n    function compAccrued(address holder) external view returns (uint256);\n}\n"
    },
    "contracts/strategies/CompoundStrategyWBTC.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"./CompoundStrategy.sol\";\nimport \"../interfaces/token/IToken.sol\";\n\n//solhint-disable no-empty-blocks\ncontract CompoundStrategyWBTC is CompoundStrategy {\n    string public constant NAME = \"Strategy-Compound-WBTC\";\n    string public constant VERSION = \"2.0.3\";\n\n    constructor(address _controller, address _pool)\n        public\n        CompoundStrategy(\n            _controller,\n            _pool,\n            0xccF4429DB6322D5C611ee964527D42E5d685DD6a,\n            0xc00e94Cb662C3520282E6f5717214004A7f26888,\n            0x3d9819210A31b4961b30EF54bE2aeD79B9c9Cd3B\n        )\n    {}\n}\n"
    },
    "contracts/interfaces/token/IToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\ninterface TokenLike {\n    function approve(address, uint256) external returns (bool);\n\n    function balanceOf(address) external view returns (uint256);\n\n    function transfer(address, uint256) external returns (bool);\n\n    function transferFrom(\n        address,\n        address,\n        uint256\n    ) external returns (bool);\n\n    function deposit() external payable;\n\n    function withdraw(uint256) external;\n}\n"
    },
    "contracts/strategies/CompoundStrategyUSDC.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"./CompoundStrategy.sol\";\nimport \"../interfaces/token/IToken.sol\";\n\n//solhint-disable no-empty-blocks\ncontract CompoundStrategyUSDC is CompoundStrategy {\n    string public constant NAME = \"Strategy-Compound-USDC\";\n    string public constant VERSION = \"2.0.2\";\n\n    constructor(address _controller, address _pool)\n        public\n        CompoundStrategy(\n            _controller,\n            _pool,\n            0x39AA39c021dfbaE8faC545936693aC917d5E7563,\n            0xc00e94Cb662C3520282E6f5717214004A7f26888,\n            0x3d9819210A31b4961b30EF54bE2aeD79B9c9Cd3B\n        )\n    {}\n}\n"
    },
    "contracts/strategies/CompoundStrategyETH.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"./CompoundStrategy.sol\";\nimport \"../interfaces/token/IToken.sol\";\n\n//solhint-disable no-empty-blocks\ncontract CompoundStrategyETH is CompoundStrategy {\n    string public constant NAME = \"Strategy-Compound-ETH\";\n    string public constant VERSION = \"2.0.3\";\n\n    constructor(address _controller, address _pool)\n        public\n        CompoundStrategy(\n            _controller,\n            _pool,\n            0x4Ddc2D193948926D02f9B1fE9e1daa0718270ED5,\n            0xc00e94Cb662C3520282E6f5717214004A7f26888,\n            0x3d9819210A31b4961b30EF54bE2aeD79B9c9Cd3B\n        )\n    {}\n\n    receive() external payable {\n        require(msg.sender == address(cToken) || msg.sender == WETH, \"Not allowed to send ether\");\n    }\n\n    /// @dev Hool to call after collateral is redeemed from Compound\n    function _afterRedeem() internal override {\n        TokenLike(WETH).deposit{value: address(this).balance}();\n    }\n\n    function _deposit(uint256 _amount) internal override {\n        collateralToken.safeTransferFrom(pool, address(this), _amount);\n        TokenLike(WETH).withdraw(_amount);\n        cToken.mint{value: _amount}();\n    }\n}\n"
    },
    "contracts/strategies/CompoundStrategyDAI.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"./CompoundStrategy.sol\";\nimport \"../interfaces/token/IToken.sol\";\n\n//solhint-disable no-empty-blocks\ncontract CompoundStrategyDAI is CompoundStrategy {\n    string public constant NAME = \"Strategy-Compound-DAI\";\n    string public constant VERSION = \"2.0.2\";\n\n    constructor(address _controller, address _pool)\n        public\n        CompoundStrategy(\n            _controller,\n            _pool,\n            0x5d3a536E4D6DbD6114cc1Ead35777bAB948E3643,\n            0xc00e94Cb662C3520282E6f5717214004A7f26888,\n            0x3d9819210A31b4961b30EF54bE2aeD79B9c9Cd3B\n        )\n    {}\n}\n"
    },
    "contracts/strategies/CompoundMakerStrategyETH.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"./CompoundMakerStrategy.sol\";\nimport \"../interfaces/token/IToken.sol\";\n\n//solhint-disable no-empty-blocks\ncontract CompoundMakerStrategyETH is CompoundMakerStrategy {\n    string public constant NAME = \"Compound-Maker-Strategy-ETH\";\n    string public constant VERSION = \"2.0.3\";\n\n    constructor(\n        address _controller,\n        address _pool,\n        address _cm\n    )\n        public\n        CompoundMakerStrategy(\n            _controller,\n            _pool,\n            _cm,\n            0x5d3a536E4D6DbD6114cc1Ead35777bAB948E3643, // cDAI\n            \"ETH-A\",\n            0xc00e94Cb662C3520282E6f5717214004A7f26888, // COMP\n            0x3d9819210A31b4961b30EF54bE2aeD79B9c9Cd3B // Comptroller\n        )\n    {}\n}\n"
    },
    "contracts/strategies/CompoundMakerStrategy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"./MakerStrategy.sol\";\nimport \"../interfaces/compound/ICompound.sol\";\n\n/// @dev This strategy will deposit collateral token in Maker, borrow Dai and\n/// deposit borrowed DAI in Compound to earn interest.\nabstract contract CompoundMakerStrategy is MakerStrategy {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    address internal immutable rewardToken;\n    CToken internal immutable cToken;\n    Comptroller internal immutable comptroller;\n\n    constructor(\n        address _controller,\n        address _pool,\n        address _cm,\n        address _receiptToken,\n        bytes32 _collateralType,\n        address _rewardToken,\n        address _comptroller\n    ) public MakerStrategy(_controller, _pool, _cm, _receiptToken, _collateralType) {\n        require(_rewardToken != address(0), \"reward-token-address-is-zero\");\n        require(_receiptToken != address(0), \"cToken-address-is-zero\");\n        require(_comptroller != address(0), \"comptroller-address-is-zero\");\n\n        rewardToken = _rewardToken;\n        cToken = CToken(_receiptToken);\n        comptroller = Comptroller(_comptroller);\n    }\n\n    /**\n     * @notice Returns earning from COMP and DAI since last rebalance.\n     * @dev Make sure to return value in collateral token and in order to do that\n     * we are using Uniswap to get collateral amount for earned CMOP and DAI.\n     */\n    function interestEarned() public view override returns (uint256 collateralEarned) {\n        uint256 _daiBalanceHere = _getDaiBalance();\n        uint256 _debt = cm.getVaultDebt(vaultNum);\n\n        if (_daiBalanceHere > _debt) {\n            (, collateralEarned, ) = swapManager.bestOutputFixedInput(\n                DAI,\n                address(collateralToken),\n                _daiBalanceHere.sub(_debt)\n            );\n        }\n\n        uint256 _compAccrued = comptroller.compAccrued(address(this));\n        if (_compAccrued != 0) {\n            (, uint256 accruedCollateral, ) =\n                swapManager.bestOutputFixedInput(\n                    rewardToken,\n                    address(collateralToken),\n                    _compAccrued\n                );\n            collateralEarned = collateralEarned.add(accruedCollateral);\n        }\n    }\n\n    /// @dev Check whether given token is reserved or not. Reserved tokens are not allowed to sweep.\n    function isReservedToken(address _token) public view override returns (bool) {\n        return _token == receiptToken || _token == rewardToken;\n    }\n\n    /**\n     * @notice Returns true if pool is underwater.\n     * @notice Underwater - If debt is greater than earning of pool.\n     * @notice Earning - Sum of DAI balance and DAI from accured reward, if any, in lending pool.\n     * @dev There can be a scenario when someone calls claimComp() periodically which will\n     * leave compAccrued = 0 and pool might be underwater. Call rebalance() to liquidate COMP.\n     */\n    function isUnderwater() public view override returns (bool) {\n        uint256 _compAccrued = comptroller.compAccrued(address(this));\n        uint256 _daiEarned;\n        if (_compAccrued != 0) {\n            (, _daiEarned, ) = swapManager.bestOutputFixedInput(rewardToken, DAI, _compAccrued);\n        }\n        return cm.getVaultDebt(vaultNum) > _getDaiBalance().add(_daiEarned);\n    }\n\n    function _approveToken(uint256 _amount) internal override {\n        super._approveToken(_amount);\n        for (uint256 i = 0; i < swapManager.N_DEX(); i++) {\n            IERC20(rewardToken).safeApprove(address(swapManager.ROUTERS(i)), _amount);\n        }\n    }\n\n    /// @notice Claim rewardToken from lender and convert it into DAI\n    function _claimReward() internal override {\n        address[] memory _markets = new address[](1);\n        _markets[0] = address(cToken);\n        comptroller.claimComp(address(this), _markets);\n\n        uint256 _rewardAmount = IERC20(rewardToken).balanceOf(address(this));\n        if (_rewardAmount != 0) {\n            _safeSwap(rewardToken, DAI, _rewardAmount);\n        }\n    }\n\n    function _depositDaiToLender(uint256 _amount) internal override {\n        require(cToken.mint(_amount) == 0, \"deposit-in-compound-failed\");\n    }\n\n    function _getDaiBalance() internal view override returns (uint256) {\n        return cToken.balanceOf(address(this)).mul(cToken.exchangeRateStored()).div(1e18);\n    }\n\n    /**\n     * @dev Rebalance DAI in lender. If lender has more DAI than DAI debt in Maker\n     * then withdraw excess DAI from lender. If lender is short on DAI, underwater,\n     * then deposit DAI to lender.\n     * @dev There may be a scenario where we do not have enough DAI to deposit to\n     * lender, in that case pool will be underwater even after rebalanceDai.\n     */\n    function _rebalanceDaiInLender() internal override {\n        uint256 _daiDebtInMaker = cm.getVaultDebt(vaultNum);\n        uint256 _daiInLender = _getDaiBalance();\n        if (_daiInLender > _daiDebtInMaker) {\n            _withdrawDaiFromLender(_daiInLender.sub(_daiDebtInMaker));\n        } else if (_daiInLender < _daiDebtInMaker) {\n            uint256 _daiBalanceHere = IERC20(DAI).balanceOf(address(this));\n            uint256 _daiNeeded = _daiDebtInMaker.sub(_daiInLender);\n            if (_daiBalanceHere > _daiNeeded) {\n                _depositDaiToLender(_daiNeeded);\n            } else {\n                _depositDaiToLender(_daiBalanceHere);\n            }\n        }\n    }\n\n    function _withdrawDaiFromLender(uint256 _amount) internal override {\n        require(cToken.redeemUnderlying(_amount) == 0, \"withdraw-from-compound-failed\");\n    }\n\n    /// dev these functions are not implemented for this strategy\n    // solhint-disable-next-line no-empty-blocks\n    function _migrateIn() internal override {}\n\n    // solhint-disable-next-line no-empty-blocks\n    function _migrateOut() internal override {}\n}\n"
    },
    "contracts/strategies/MakerStrategy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"./Strategy.sol\";\nimport \"../interfaces/vesper/ICollateralManager.sol\";\nimport \"../interfaces/uniswap/IUniswapV2Router02.sol\";\n\ninterface ManagerInterface {\n    function vat() external view returns (address);\n\n    function open(bytes32, address) external returns (uint256);\n\n    function cdpAllow(\n        uint256,\n        address,\n        uint256\n    ) external;\n}\n\ninterface VatInterface {\n    function hope(address) external;\n\n    function nope(address) external;\n}\n\n/// @dev This strategy will deposit collateral token in Maker, borrow Dai and\n/// deposit borrowed DAI in other lending pool to earn interest.\nabstract contract MakerStrategy is Strategy {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    address internal constant DAI = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\n    ICollateralManager public immutable cm;\n    bytes32 public immutable collateralType;\n    uint256 public immutable vaultNum;\n    uint256 public lastRebalanceBlock;\n    uint256 public highWater;\n    uint256 public lowWater;\n    uint256 private constant WAT = 10**16;\n\n    constructor(\n        address _controller,\n        address _pool,\n        address _cm,\n        address _receiptToken,\n        bytes32 _collateralType\n    ) public Strategy(_controller, _pool, _receiptToken) {\n        collateralType = _collateralType;\n        vaultNum = _createVault(_collateralType, _cm);\n        cm = ICollateralManager(_cm);\n    }\n\n    /**\n     * @dev Called during withdrawal process.\n     * Initial plan was to not allowed withdraw if pool in underwater. BUT as 1 of\n     * audit suggested we should not use resurface during withdraw, hence removed logic.\n     */\n    //solhint-disable-next-line no-empty-blocks\n    function beforeWithdraw() external override onlyPool {}\n\n    /**\n     * @dev Rebalance earning and withdraw all collateral.\n     * Controller only function, called when migrating strategy.\n     */\n    function withdrawAllWithRebalance() external onlyController {\n        _rebalanceEarned();\n        _withdrawAll();\n    }\n\n    /**\n     * @dev Wrapper function for rebalanceEarned and rebalanceCollateral\n     * Anyone can call it except when paused.\n     */\n    function rebalance() external override onlyKeeper {\n        _rebalanceEarned();\n        _rebalanceCollateral();\n    }\n\n    /**\n     * @dev Rebalance collateral and debt in Maker.\n     * Based on defined risk parameter either borrow more DAI from Maker or\n     * payback some DAI in Maker. It will try to mitigate risk of liquidation.\n     * Anyone can call it except when paused.\n     */\n    function rebalanceCollateral() external onlyKeeper {\n        _rebalanceCollateral();\n    }\n\n    /**\n     * @dev Convert earned DAI to collateral token\n     * Also calculate interest fee on earning and transfer fee to fee collector.\n     * Anyone can call it except when paused.\n     */\n    function rebalanceEarned() external onlyKeeper {\n        _rebalanceEarned();\n    }\n\n    /**\n     * @dev If pool is underwater this function will resolve underwater condition.\n     * If Debt in Maker is greater than Dai balance in lender pool then pool in underwater.\n     * Lowering DAI debt in Maker will resolve underwater condtion.\n     * Resolve: Calculate required collateral token to lower DAI debt. Withdraw required\n     * collateral token from pool and/or Maker and convert those to DAI via Uniswap.\n     * Finally payback debt in Maker using DAI.\n     */\n    function resurface() external onlyKeeper {\n        _resurface();\n    }\n\n    /**\n     * @notice Update balancing factors aka high water and low water values.\n     * Water mark values represent Collateral Ratio in Maker. For example 300 as high water\n     * means 300% collateral ratio.\n     * @param _highWater Value for high water mark.\n     * @param _lowWater Value for low water mark.\n     */\n    function updateBalancingFactor(uint256 _highWater, uint256 _lowWater) external onlyController {\n        require(_lowWater != 0, \"lowWater-is-zero\");\n        require(_highWater > _lowWater, \"highWater-less-than-lowWater\");\n        highWater = _highWater.mul(WAT);\n        lowWater = _lowWater.mul(WAT);\n    }\n\n    /**\n     * @notice Returns interest earned since last rebalance.\n     * @dev Make sure to return value in collateral token and in order to do that\n     * we are using Uniswap to get collateral amount for earned DAI.\n     */\n    function interestEarned() public view virtual override returns (uint256 amountOut) {\n        uint256 _daiBalance = _getDaiBalance();\n        uint256 _debt = cm.getVaultDebt(vaultNum);\n        if (_daiBalance > _debt) {\n            (, amountOut, ) = swapManager.bestOutputFixedInput(\n                DAI,\n                address(collateralToken),\n                _daiBalance.sub(_debt)\n            );\n        }\n    }\n\n    /// @dev Check whether given token is reserved or not. Reserved tokens are not allowed to sweep.\n    function isReservedToken(address _token) public view virtual override returns (bool) {\n        return _token == receiptToken;\n    }\n\n    /**\n     * @notice Returns true if pool is underwater.\n     * @notice Underwater - If debt is greater than earning of pool.\n     * @notice Earning - Sum of DAI balance and DAI from accured reward, if any, in lending pool.\n     */\n    function isUnderwater() public view virtual returns (bool) {\n        return cm.getVaultDebt(vaultNum) > _getDaiBalance();\n    }\n\n    /// @dev Returns total collateral locked via this strategy\n    function totalLocked() public view virtual override returns (uint256) {\n        return convertFrom18(cm.getVaultBalance(vaultNum));\n    }\n\n    /// @dev Create new Maker vault\n    function _createVault(bytes32 _collateralType, address _cm) internal returns (uint256 vaultId) {\n        address mcdManager = ICollateralManager(_cm).mcdManager();\n        ManagerInterface manager = ManagerInterface(mcdManager);\n        vaultId = manager.open(_collateralType, address(this));\n        manager.cdpAllow(vaultId, address(this), 1);\n\n        //hope and cpdAllow on vat for collateralManager's address\n        VatInterface(manager.vat()).hope(_cm);\n        manager.cdpAllow(vaultId, _cm, 1);\n\n        //Register vault with collateral Manager\n        ICollateralManager(_cm).registerVault(vaultId, _collateralType);\n    }\n\n    function _approveToken(uint256 _amount) internal virtual override {\n        IERC20(DAI).safeApprove(address(cm), _amount);\n        IERC20(DAI).safeApprove(address(receiptToken), _amount);\n        collateralToken.safeApprove(address(cm), _amount);\n        collateralToken.safeApprove(pool, _amount);\n        for (uint256 i = 0; i < swapManager.N_DEX(); i++) {\n            IERC20(DAI).safeApprove(address(swapManager.ROUTERS(i)), _amount);\n            collateralToken.safeApprove(address(swapManager.ROUTERS(i)), _amount);\n        }\n    }\n\n    function _deposit(uint256 _amount) internal override {\n        collateralToken.safeTransferFrom(pool, address(this), _amount);\n        cm.depositCollateral(vaultNum, _amount);\n    }\n\n    function _depositDaiToLender(uint256 _amount) internal virtual;\n\n    function _moveDaiToMaker(uint256 _amount) internal {\n        if (_amount != 0) {\n            _withdrawDaiFromLender(_amount);\n            cm.payback(vaultNum, _amount);\n        }\n    }\n\n    function _moveDaiFromMaker(uint256 _amount) internal virtual {\n        cm.borrow(vaultNum, _amount);\n        _amount = IERC20(DAI).balanceOf(address(this));\n        _depositDaiToLender(_amount);\n    }\n\n    function _swapBalanceToCollateral(address _from) internal {\n        uint256 amt = IERC20(_from).balanceOf(address(this));\n        if (amt != 0) {\n            _safeSwap(_from, address(collateralToken), amt);\n        }\n    }\n\n    function _rebalanceCollateral() internal virtual {\n        _deposit(collateralToken.balanceOf(pool));\n        (\n            uint256 collateralLocked,\n            uint256 debt,\n            uint256 collateralUsdRate,\n            uint256 collateralRatio,\n            uint256 minimumDebt\n        ) = cm.getVaultInfo(vaultNum);\n        uint256 maxDebt = collateralLocked.mul(collateralUsdRate).div(highWater);\n        if (maxDebt < minimumDebt) {\n            // Dusting scenario. Payback all DAI\n            _moveDaiToMaker(debt);\n        } else {\n            if (collateralRatio > highWater) {\n                require(!isUnderwater(), \"pool-is-underwater\");\n                _moveDaiFromMaker(maxDebt.sub(debt));\n            } else if (collateralRatio < lowWater) {\n                // Redeem DAI from Lender and deposit in maker\n                _moveDaiToMaker(debt.sub(maxDebt));\n            }\n        }\n    }\n\n    function _rebalanceEarned() internal virtual {\n        require(\n            (block.number - lastRebalanceBlock) >= controller.rebalanceFriction(pool),\n            \"can-not-rebalance\"\n        );\n        lastRebalanceBlock = block.number;\n        _claimReward();\n        _rebalanceDaiInLender();\n        _swapBalanceToCollateral(DAI);\n        uint256 collateralBalance = collateralToken.balanceOf(address(this));\n        if (collateralBalance != 0) {\n            uint256 fee = collateralBalance.mul(controller.interestFee(pool)).div(1e18);\n            collateralToken.safeTransfer(pool, collateralBalance.sub(fee));\n            _handleFee(fee);\n        }\n    }\n\n    function _resurface() internal {\n        uint256 earnBalance = _getDaiBalance();\n        uint256 debt = cm.getVaultDebt(vaultNum);\n        require(debt > earnBalance, \"pool-is-above-water\");\n        uint256 shortAmount = debt.sub(earnBalance);\n        _paybackShortAmount(shortAmount);\n    }\n\n    function _paybackShortAmount(uint256 shortAmount) internal virtual {\n        (address[] memory path, uint256 collateralNeeded, uint256 rIdx) =\n            swapManager.bestInputFixedOutput(address(collateralToken), DAI, shortAmount);\n        if (collateralNeeded != 0) {\n            uint256 balance = collateralToken.balanceOf(pool);\n\n            // If pool has more balance than tokenNeeded, get what needed from pool\n            // else get pool balance from pool and remaining from Maker vault\n            if (balance >= collateralNeeded) {\n                collateralToken.safeTransferFrom(pool, address(this), collateralNeeded);\n            } else {\n                cm.withdrawCollateral(vaultNum, collateralNeeded.sub(balance));\n                collateralToken.safeTransferFrom(pool, address(this), balance);\n            }\n            swapManager.ROUTERS(rIdx).swapExactTokensForTokens(\n                collateralNeeded,\n                1,\n                path,\n                address(this),\n                block.timestamp\n            );\n            uint256 daiBalance = IERC20(DAI).balanceOf(address(this));\n            cm.payback(vaultNum, daiBalance);\n        }\n\n        // If any collateral dust then send it to pool\n        uint256 _collateralbalance = collateralToken.balanceOf(address(this));\n        if (_collateralbalance != 0) {\n            collateralToken.safeTransfer(pool, _collateralbalance);\n        }\n    }\n\n    function _withdraw(uint256 _amount) internal override {\n        (\n            uint256 collateralLocked,\n            uint256 debt,\n            uint256 collateralUsdRate,\n            uint256 collateralRatio,\n            uint256 minimumDebt\n        ) = cm.whatWouldWithdrawDo(vaultNum, _amount);\n        if (debt != 0 && collateralRatio < lowWater) {\n            // If this withdraw results in Low Water scenario.\n            uint256 maxDebt = collateralLocked.mul(collateralUsdRate).div(highWater);\n            if (maxDebt < minimumDebt) {\n                // This is Dusting scenario\n                _moveDaiToMaker(debt);\n            } else if (maxDebt < debt) {\n                _moveDaiToMaker(debt.sub(maxDebt));\n            }\n        }\n        cm.withdrawCollateral(vaultNum, _amount);\n        collateralToken.safeTransfer(pool, collateralToken.balanceOf(address(this)));\n    }\n\n    function _withdrawAll() internal override {\n        _moveDaiToMaker(cm.getVaultDebt(vaultNum));\n        require(cm.getVaultDebt(vaultNum) == 0, \"debt-should-be-0\");\n        cm.withdrawCollateral(vaultNum, totalLocked());\n        collateralToken.safeTransfer(pool, collateralToken.balanceOf(address(this)));\n    }\n\n    function _withdrawDaiFromLender(uint256 _amount) internal virtual;\n\n    function _rebalanceDaiInLender() internal virtual {\n        uint256 debt = cm.getVaultDebt(vaultNum);\n        uint256 balance = _getDaiBalance();\n        if (balance > debt) {\n            _withdrawDaiFromLender(balance.sub(debt));\n        }\n    }\n\n    function _getDaiBalance() internal view virtual returns (uint256);\n\n    /// Calculating pending fee is not required for Maker strategy\n    // solhint-disable-next-line no-empty-blocks\n    function _updatePendingFee() internal virtual override {}\n\n    //solhint-disable-next-line no-empty-blocks\n    function _claimReward() internal virtual override {}\n}\n"
    },
    "contracts/interfaces/vesper/ICollateralManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\ninterface ICollateralManager {\n    function addGemJoin(address[] calldata gemJoins) external;\n\n    function mcdManager() external view returns (address);\n\n    function borrow(uint256 vaultNum, uint256 amount) external;\n\n    function depositCollateral(uint256 vaultNum, uint256 amount) external;\n\n    function getVaultBalance(uint256 vaultNum) external view returns (uint256 collateralLocked);\n\n    function getVaultDebt(uint256 vaultNum) external view returns (uint256 daiDebt);\n\n    function getVaultInfo(uint256 vaultNum)\n        external\n        view\n        returns (\n            uint256 collateralLocked,\n            uint256 daiDebt,\n            uint256 collateralUsdRate,\n            uint256 collateralRatio,\n            uint256 minimumDebt\n        );\n\n    function payback(uint256 vaultNum, uint256 amount) external;\n\n    function registerVault(uint256 vaultNum, bytes32 collateralType) external;\n\n    function vaultOwner(uint256 vaultNum) external returns (address owner);\n\n    function whatWouldWithdrawDo(uint256 vaultNum, uint256 amount)\n        external\n        view\n        returns (\n            uint256 collateralLocked,\n            uint256 daiDebt,\n            uint256 collateralUsdRate,\n            uint256 collateralRatio,\n            uint256 minimumDebt\n        );\n\n    function withdrawCollateral(uint256 vaultNum, uint256 amount) external;\n}\n"
    },
    "contracts/strategies/VesperMakerStrategy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"./MakerStrategy.sol\";\n\n/// @dev This strategy will deposit collateral token in Maker, borrow Dai and\n/// deposit borrowed DAI in Vesper DAI pool to earn interest.\nabstract contract VesperMakerStrategy is MakerStrategy {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    constructor(\n        address _controller,\n        address _pool,\n        address _cm,\n        address _vPool,\n        bytes32 _collateralType\n    ) public MakerStrategy(_controller, _pool, _cm, _vPool, _collateralType) {\n        require(IController(_controller).isPool(_vPool), \"not-a-valid-vPool\");\n        require(IVesperPool(_vPool).token() == DAI, \"not-a-valid-dai-pool\");\n    }\n\n    function _getDaiBalance() internal view override returns (uint256) {\n        return\n            (IVesperPool(receiptToken).getPricePerShare())\n                .mul(IVesperPool(receiptToken).balanceOf(address(this)))\n                .div(1e18);\n    }\n\n    function _depositDaiToLender(uint256 _amount) internal override {\n        IVesperPool(receiptToken).deposit(_amount);\n    }\n\n    function _withdrawDaiFromLender(uint256 _amount) internal override {\n        uint256 vAmount = _amount.mul(1e18).div(IVesperPool(receiptToken).getPricePerShare());\n        IVesperPool(receiptToken).withdrawByStrategy(vAmount);\n    }\n\n    /// dev these functions are not implemented for this strategy\n    // solhint-disable-next-line no-empty-blocks\n    function _migrateIn() internal override {}\n\n    // solhint-disable-next-line no-empty-blocks\n    function _migrateOut() internal override {}\n}\n"
    },
    "contracts/strategies/VesperMakerStrategyLINK.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"./VesperMakerStrategy.sol\";\n\n//solhint-disable no-empty-blocks\ncontract VesperMakerStrategyLINK is VesperMakerStrategy {\n    string public constant NAME = \"Strategy-Vesper-Maker-LINK\";\n    string public constant VERSION = \"2.0.4\";\n\n    constructor(\n        address _controller,\n        address _pool,\n        address _cm,\n        address _vPool\n    ) public VesperMakerStrategy(_controller, _pool, _cm, _vPool, \"LINK-A\") {}\n}\n"
    },
    "contracts/strategies/VesperMakerStrategyETH.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"./VesperMakerStrategy.sol\";\n\n//solhint-disable no-empty-blocks\ncontract VesperMakerStrategyETH is VesperMakerStrategy {\n    string public constant NAME = \"Strategy-Vesper-Maker-ETH\";\n    string public constant VERSION = \"2.0.3\";\n\n    constructor(\n        address _controller,\n        address _pool,\n        address _cm,\n        address _vPool\n    ) public VesperMakerStrategy(_controller, _pool, _cm, _vPool, \"ETH-A\") {}\n}\n"
    },
    "contracts/pools/VTokenBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"./PoolShareToken.sol\";\nimport \"../interfaces/uniswap/IUniswapV2Router02.sol\";\nimport \"../interfaces/vesper/IStrategy.sol\";\n\nabstract contract VTokenBase is PoolShareToken {\n    address internal constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n\n    constructor(\n        string memory name,\n        string memory symbol,\n        address _token,\n        address _controller\n    ) public PoolShareToken(name, symbol, _token, _controller) {\n        require(_controller != address(0), \"Controller address is zero\");\n    }\n\n    modifier onlyController() {\n        require(address(controller) == _msgSender(), \"Caller is not the controller\");\n        _;\n    }\n\n    function pause() external onlyController {\n        _pause();\n    }\n\n    function unpause() external onlyController {\n        _unpause();\n    }\n\n    function shutdown() external onlyController {\n        _shutdown();\n    }\n\n    function open() external onlyController {\n        _open();\n    }\n\n    /// @dev Approve strategy to spend collateral token and strategy token of pool.\n    function approveToken() external virtual onlyController {\n        address strategy = controller.strategy(address(this));\n        token.safeApprove(strategy, MAX_UINT_VALUE);\n        IERC20(IStrategy(strategy).token()).safeApprove(strategy, MAX_UINT_VALUE);\n    }\n\n    /// @dev Reset token approval of strategy. Called when updating strategy.\n    function resetApproval() external virtual onlyController {\n        address strategy = controller.strategy(address(this));\n        token.safeApprove(strategy, 0);\n        IERC20(IStrategy(strategy).token()).safeApprove(strategy, 0);\n    }\n\n    /**\n     * @dev Rebalance invested collateral to mitigate liquidation risk, if any.\n     * Behavior of rebalance is driven by risk parameters defined in strategy.\n     */\n    function rebalance() external virtual {\n        IStrategy strategy = IStrategy(controller.strategy(address(this)));\n        strategy.rebalance();\n    }\n\n    /**\n     * @dev Convert given ERC20 token into collateral token via Uniswap\n     * @param _erc20 Token address\n     */\n    function sweepErc20(address _erc20) external virtual {\n        _sweepErc20(_erc20);\n    }\n\n    /// @dev Returns collateral token locked in strategy\n    function tokenLocked() public view virtual returns (uint256) {\n        IStrategy strategy = IStrategy(controller.strategy(address(this)));\n        return strategy.totalLocked();\n    }\n\n    /// @dev Returns total value of vesper pool, in terms of collateral token\n    function totalValue() public view override returns (uint256) {\n        return tokenLocked().add(tokensHere());\n    }\n\n    /**\n     * @dev After burning hook, it will be called during withdrawal process.\n     * It will withdraw collateral from strategy and transfer it to user.\n     */\n    function _afterBurning(uint256 _amount) internal override {\n        uint256 balanceHere = tokensHere();\n        if (balanceHere < _amount) {\n            _withdrawCollateral(_amount.sub(balanceHere));\n            balanceHere = tokensHere();\n            _amount = balanceHere < _amount ? balanceHere : _amount;\n        }\n        token.safeTransfer(_msgSender(), _amount);\n    }\n\n    /**\n     * @dev Before burning hook.\n     * Some actions, like resurface(), can impact share price and has to be called before withdraw.\n     */\n    function _beforeBurning(\n        uint256 /* shares */\n    ) internal override {\n        IStrategy strategy = IStrategy(controller.strategy(address(this)));\n        strategy.beforeWithdraw();\n    }\n\n    function _beforeMinting(uint256 amount) internal override {\n        token.safeTransferFrom(_msgSender(), address(this), amount);\n    }\n\n    function _withdrawCollateral(uint256 amount) internal virtual {\n        IStrategy strategy = IStrategy(controller.strategy(address(this)));\n        strategy.withdraw(amount);\n    }\n\n    function _sweepErc20(address _from) internal {\n        IStrategy strategy = IStrategy(controller.strategy(address(this)));\n        require(\n            _from != address(token) && _from != address(this) && !strategy.isReservedToken(_from),\n            \"Not allowed to sweep\"\n        );\n        IUniswapV2Router02 uniswapRouter = IUniswapV2Router02(controller.uniswapRouter());\n        uint256 amt = IERC20(_from).balanceOf(address(this));\n        IERC20(_from).safeApprove(address(uniswapRouter), 0);\n        IERC20(_from).safeApprove(address(uniswapRouter), amt);\n        address[] memory path;\n        if (address(token) == WETH) {\n            path = new address[](2);\n            path[0] = _from;\n            path[1] = address(token);\n        } else {\n            path = new address[](3);\n            path[0] = _from;\n            path[1] = WETH;\n            path[2] = address(token);\n        }\n        uniswapRouter.swapExactTokensForTokens(amt, 1, path, address(this), now + 30);\n    }\n}\n"
    },
    "contracts/pools/PoolShareToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"../Pausable.sol\";\nimport \"../interfaces/vesper/IController.sol\";\nimport \"../interfaces/vesper/IVesperPool.sol\";\nimport \"../interfaces/vesper/IPoolRewards.sol\";\nimport \"../../sol-address-list/contracts/interfaces/IAddressListExt.sol\";\nimport \"../../sol-address-list/contracts/interfaces/IAddressListFactory.sol\";\n\n/// @title Holding pool share token\n// solhint-disable no-empty-blocks\nabstract contract PoolShareToken is ERC20, Pausable, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n    IERC20 public immutable token;\n    IAddressListExt public immutable feeWhiteList;\n    IController public immutable controller;\n\n    /// @dev The EIP-712 typehash for the contract's domain\n    bytes32 public constant DOMAIN_TYPEHASH =\n        keccak256(\n            \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n        );\n\n    /// @dev The EIP-712 typehash for the permit struct used by the contract\n    bytes32 public constant PERMIT_TYPEHASH =\n        keccak256(\n            \"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\"\n        );\n\n    bytes32 public immutable domainSeparator;\n\n    uint256 internal constant MAX_UINT_VALUE = type(uint256).max;\n    mapping(address => uint256) public nonces;\n    event Deposit(address indexed owner, uint256 shares, uint256 amount);\n    event Withdraw(address indexed owner, uint256 shares, uint256 amount);\n\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        address _token,\n        address _controller\n    ) public ERC20(_name, _symbol) {\n        uint256 chainId;\n        assembly {\n            chainId := chainid()\n        }\n        token = IERC20(_token);\n        controller = IController(_controller);\n        IAddressListFactory factory =\n            IAddressListFactory(0xD57b41649f822C51a73C44Ba0B3da4A880aF0029);\n        IAddressListExt _feeWhiteList = IAddressListExt(factory.createList());\n        _feeWhiteList.grantRole(keccak256(\"LIST_ADMIN\"), _controller);\n        feeWhiteList = _feeWhiteList;\n        domainSeparator = keccak256(\n            abi.encode(\n                DOMAIN_TYPEHASH,\n                keccak256(bytes(_name)),\n                keccak256(bytes(\"1\")),\n                chainId,\n                address(this)\n            )\n        );\n    }\n\n    /**\n     * @notice Deposit ERC20 tokens and receive pool shares depending on the current share price.\n     * @param amount ERC20 token amount.\n     */\n    function deposit(uint256 amount) external virtual nonReentrant whenNotPaused {\n        _deposit(amount);\n    }\n\n    /**\n     * @notice Deposit ERC20 tokens with permit aka gasless approval.\n     * @param amount ERC20 token amount.\n     * @param deadline The time at which signature will expire\n     * @param v The recovery byte of the signature\n     * @param r Half of the ECDSA signature pair\n     * @param s Half of the ECDSA signature pair\n     */\n    function depositWithPermit(\n        uint256 amount,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external virtual nonReentrant whenNotPaused {\n        IVesperPool(address(token)).permit(_msgSender(), address(this), amount, deadline, v, r, s);\n        _deposit(amount);\n    }\n\n    /**\n     * @notice Withdraw collateral based on given shares and the current share price.\n     * Transfer earned rewards to caller. Withdraw fee, if any, will be deduced from\n     * given shares and transferred to feeCollector. Burn remaining shares and return collateral.\n     * @param shares Pool shares. It will be in 18 decimals.\n     */\n    function withdraw(uint256 shares) external virtual nonReentrant whenNotShutdown {\n        _withdraw(shares);\n    }\n\n    /**\n     * @notice Withdraw collateral based on given shares and the current share price.\n     * Transfer earned rewards to caller. Burn shares and return collateral.\n     * @dev No withdraw fee will be assessed when this function is called.\n     * Only some white listed address can call this function.\n     * @param shares Pool shares. It will be in 18 decimals.\n     */\n    function withdrawByStrategy(uint256 shares) external virtual nonReentrant whenNotShutdown {\n        require(feeWhiteList.get(_msgSender()) != 0, \"Not a white listed address\");\n        _withdrawByStrategy(shares);\n    }\n\n    /**\n     * @notice Transfer tokens to multiple recipient\n     * @dev Left 160 bits are the recipient address and the right 96 bits are the token amount.\n     * @param bits array of uint\n     * @return true/false\n     */\n    function multiTransfer(uint256[] memory bits) external returns (bool) {\n        for (uint256 i = 0; i < bits.length; i++) {\n            address a = address(bits[i] >> 96);\n            uint256 amount = bits[i] & ((1 << 96) - 1);\n            require(transfer(a, amount), \"Transfer failed\");\n        }\n        return true;\n    }\n\n    /**\n     * @notice Triggers an approval from owner to spends\n     * @param owner The address to approve from\n     * @param spender The address to be approved\n     * @param amount The number of tokens that are approved (2^256-1 means infinite)\n     * @param deadline The time at which to expire the signature\n     * @param v The recovery byte of the signature\n     * @param r Half of the ECDSA signature pair\n     * @param s Half of the ECDSA signature pair\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 amount,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external {\n        require(deadline >= block.timestamp, \"Expired\");\n        bytes32 digest =\n            keccak256(\n                abi.encodePacked(\n                    \"\\x19\\x01\",\n                    domainSeparator,\n                    keccak256(\n                        abi.encode(\n                            PERMIT_TYPEHASH,\n                            owner,\n                            spender,\n                            amount,\n                            nonces[owner]++,\n                            deadline\n                        )\n                    )\n                )\n            );\n        address signatory = ecrecover(digest, v, r, s);\n        require(signatory != address(0) && signatory == owner, \"Invalid signature\");\n        _approve(owner, spender, amount);\n    }\n\n    /**\n     * @notice Get price per share\n     * @dev Return value will be in token defined decimals.\n     */\n    function getPricePerShare() external view returns (uint256) {\n        if (totalSupply() == 0) {\n            return convertFrom18(1e18);\n        }\n        return totalValue().mul(1e18).div(totalSupply());\n    }\n\n    /// @dev Convert to 18 decimals from token defined decimals. Default no conversion.\n    function convertTo18(uint256 amount) public pure virtual returns (uint256) {\n        return amount;\n    }\n\n    /// @dev Convert from 18 decimals to token defined decimals. Default no conversion.\n    function convertFrom18(uint256 amount) public pure virtual returns (uint256) {\n        return amount;\n    }\n\n    /// @dev Get fee collector address\n    function feeCollector() public view virtual returns (address) {\n        return controller.feeCollector(address(this));\n    }\n\n    /// @dev Returns the token stored in the pool. It will be in token defined decimals.\n    function tokensHere() public view virtual returns (uint256) {\n        return token.balanceOf(address(this));\n    }\n\n    /**\n     * @dev Returns sum of token locked in other contracts and token stored in the pool.\n     * Default tokensHere. It will be in token defined decimals.\n     */\n    function totalValue() public view virtual returns (uint256) {\n        return tokensHere();\n    }\n\n    /**\n     * @notice Get withdraw fee for this pool\n     * @dev Format: 1e16 = 1% fee\n     */\n    function withdrawFee() public view virtual returns (uint256) {\n        return controller.withdrawFee(address(this));\n    }\n\n    /**\n     * @dev Hook that is called just before burning tokens. To be used i.e. if\n     * collateral is stored in a different contract and needs to be withdrawn.\n     * @param share Pool share in 18 decimals\n     */\n    function _beforeBurning(uint256 share) internal virtual {}\n\n    /**\n     * @dev Hook that is called just after burning tokens. To be used i.e. if\n     * collateral stored in a different/this contract needs to be transferred.\n     * @param amount Collateral amount in collateral token defined decimals.\n     */\n    function _afterBurning(uint256 amount) internal virtual {}\n\n    /**\n     * @dev Hook that is called just before minting new tokens. To be used i.e.\n     * if the deposited amount is to be transferred from user to this contract.\n     * @param amount Collateral amount in collateral token defined decimals.\n     */\n    function _beforeMinting(uint256 amount) internal virtual {}\n\n    /**\n     * @dev Hook that is called just after minting new tokens. To be used i.e.\n     * if the deposited amount is to be transferred to a different contract.\n     * @param amount Collateral amount in collateral token defined decimals.\n     */\n    function _afterMinting(uint256 amount) internal virtual {}\n\n    /**\n     * @dev Calculate shares to mint based on the current share price and given amount.\n     * @param amount Collateral amount in collateral token defined decimals.\n     */\n    function _calculateShares(uint256 amount) internal view returns (uint256) {\n        require(amount != 0, \"amount is 0\");\n\n        uint256 _totalSupply = totalSupply();\n        uint256 _totalValue = convertTo18(totalValue());\n        uint256 shares =\n            (_totalSupply == 0 || _totalValue == 0)\n                ? amount\n                : amount.mul(_totalSupply).div(_totalValue);\n        return shares;\n    }\n\n    /// @dev Deposit incoming token and mint pool token i.e. shares.\n    function _deposit(uint256 amount) internal {\n        uint256 shares = _calculateShares(convertTo18(amount));\n        _beforeMinting(amount);\n        _mint(_msgSender(), shares);\n        _afterMinting(amount);\n        emit Deposit(_msgSender(), shares, amount);\n    }\n\n    /// @dev Handle withdraw fee calculation and fee transfer to fee collector.\n    function _handleFee(uint256 shares) internal returns (uint256 _sharesAfterFee) {\n        if (withdrawFee() != 0) {\n            uint256 _fee = shares.mul(withdrawFee()).div(1e18);\n            _sharesAfterFee = shares.sub(_fee);\n            _transfer(_msgSender(), feeCollector(), _fee);\n        } else {\n            _sharesAfterFee = shares;\n        }\n    }\n\n    /// @dev Update pool reward of sender and receiver before transfer.\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 /* amount */\n    ) internal virtual override {\n        address poolRewards = controller.poolRewards(address(this));\n        if (poolRewards != address(0)) {\n            if (from != address(0)) {\n                IPoolRewards(poolRewards).updateReward(from);\n            }\n            if (to != address(0)) {\n                IPoolRewards(poolRewards).updateReward(to);\n            }\n        }\n    }\n\n    /// @dev Burns shares and returns the collateral value, after fee, of those.\n    function _withdraw(uint256 shares) internal {\n        require(shares != 0, \"share is 0\");\n        _beforeBurning(shares);\n        uint256 sharesAfterFee = _handleFee(shares);\n        uint256 amount =\n            convertFrom18(sharesAfterFee.mul(convertTo18(totalValue())).div(totalSupply()));\n\n        _burn(_msgSender(), sharesAfterFee);\n        _afterBurning(amount);\n        emit Withdraw(_msgSender(), shares, amount);\n    }\n\n    /// @dev Burns shares and returns the collateral value of those.\n    function _withdrawByStrategy(uint256 shares) internal {\n        require(shares != 0, \"Withdraw must be greater than 0\");\n        _beforeBurning(shares);\n        uint256 amount = convertFrom18(shares.mul(convertTo18(totalValue())).div(totalSupply()));\n        _burn(_msgSender(), shares);\n        _afterBurning(amount);\n        emit Withdraw(_msgSender(), shares, amount);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor () internal {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "contracts/pools/VWBTC.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"./VTokenBase.sol\";\n\n//solhint-disable no-empty-blocks\ncontract VWBTC is VTokenBase {\n    constructor(address _controller)\n        public\n        VTokenBase(\"vWBTC Pool\", \"vWBTC\", 0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599, _controller)\n    {}\n\n    /// @dev Convert to 18 decimals from token defined decimals.\n    function convertTo18(uint256 _value) public pure override returns (uint256) {\n        return _value.mul(10**10);\n    }\n\n    /// @dev Convert from 18 decimals to token defined decimals.\n    function convertFrom18(uint256 _value) public pure override returns (uint256) {\n        return _value.div(10**10);\n    }\n}\n"
    },
    "contracts/pools/VUSDC.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"./VTokenBase.sol\";\n\n//solhint-disable no-empty-blocks\ncontract VUSDC is VTokenBase {\n    constructor(address _controller)\n        public\n        VTokenBase(\"vUSDC Pool\", \"vUSDC\", 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48, _controller)\n    {}\n\n    /// @dev Convert to 18 decimals from token defined decimals.\n    function convertTo18(uint256 _value) public pure override returns (uint256) {\n        return _value.mul(10**12);\n    }\n\n    /// @dev Convert from 18 decimals to token defined decimals.\n    function convertFrom18(uint256 _value) public pure override returns (uint256) {\n        return _value.div(10**12);\n    }\n}\n"
    },
    "contracts/pools/VLINK.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"./VTokenBase.sol\";\n\n//solhint-disable no-empty-blocks\ncontract VLINK is VTokenBase {\n    constructor(address _controller)\n        public\n        VTokenBase(\"vLINK Pool\", \"vLINK\", 0x514910771AF9Ca656af840dff83E8264EcF986CA, _controller)\n    {}\n}\n"
    },
    "contracts/pools/VETH.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"./VTokenBase.sol\";\nimport \"../interfaces/token/IToken.sol\";\n\ncontract VETH is VTokenBase {\n    TokenLike public immutable weth;\n    bool internal shouldDeposit = true;\n\n    constructor(address _controller)\n        public\n        VTokenBase(\"vETH Pool\", \"vETH\", 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2, _controller)\n    {\n        weth = TokenLike(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n    }\n\n    /// @dev Handle incoming ETH to the contract address.\n    receive() external payable {\n        if (shouldDeposit) {\n            deposit();\n        }\n    }\n\n    /// @dev Burns tokens/shares and returns the ETH value, after fee, of those.\n    function withdrawETH(uint256 shares) external whenNotShutdown nonReentrant {\n        require(shares != 0, \"Withdraw must be greater than 0\");\n        _beforeBurning(shares);\n        uint256 sharesAfterFee = _handleFee(shares);\n        uint256 amount = sharesAfterFee.mul(totalValue()).div(totalSupply());\n        _burn(_msgSender(), sharesAfterFee);\n\n        uint256 balanceHere = tokensHere();\n        if (balanceHere < amount) {\n            _withdrawCollateral(amount.sub(balanceHere));\n            balanceHere = tokensHere();\n            amount = balanceHere < amount ? balanceHere : amount;\n        }\n        // Unwrap WETH to ETH\n        shouldDeposit = false;\n        weth.withdraw(amount);\n        shouldDeposit = true;\n        Address.sendValue(_msgSender(), amount);\n\n        emit Withdraw(_msgSender(), shares, amount);\n    }\n\n    /**\n     * @dev Receives ETH and grants new tokens/shares to the sender depending\n     * on the value of pool's share.\n     */\n    function deposit() public payable whenNotPaused nonReentrant {\n        uint256 shares = _calculateShares(msg.value);\n        // Wraps ETH in WETH\n        weth.deposit{value: msg.value}();\n        _mint(_msgSender(), shares);\n    }\n}\n"
    },
    "contracts/pools/PoolRewards.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"../interfaces/vesper/IController.sol\";\nimport \"../interfaces/vesper/IPoolRewards.sol\";\n\ncontract PoolRewards is IPoolRewards, ReentrancyGuard {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n    address public immutable override pool;\n    IERC20 public immutable rewardToken;\n    IController public immutable controller;\n    uint256 public periodFinish = 0;\n    uint256 public rewardRate = 0;\n    uint256 public constant REWARD_DURATION = 30 days;\n    uint256 public lastUpdateTime;\n    uint256 public rewardPerTokenStored;\n    mapping(address => uint256) public userRewardPerTokenPaid;\n    mapping(address => uint256) public rewards;\n    event RewardAdded(uint256 reward);\n\n    constructor(\n        address _pool,\n        address _rewardToken,\n        address _controller\n    ) public {\n        require(_controller != address(0), \"Controller address is zero\");\n        controller = IController(_controller);\n        rewardToken = IERC20(_rewardToken);\n        pool = _pool;\n    }\n\n    event RewardPaid(address indexed user, uint256 reward);\n\n    /**\n     * @dev Notify that reward is added.\n     * Also updates reward rate and reward earning period.\n     */\n    function notifyRewardAmount(uint256 rewardAmount) external override {\n        _updateReward(address(0));\n        require(msg.sender == address(controller), \"Not authorized\");\n        require(address(rewardToken) != address(0), \"Rewards token not set\");\n        if (block.timestamp >= periodFinish) {\n            rewardRate = rewardAmount.div(REWARD_DURATION);\n        } else {\n            uint256 remaining = periodFinish.sub(block.timestamp);\n            uint256 leftover = remaining.mul(rewardRate);\n            rewardRate = rewardAmount.add(leftover).div(REWARD_DURATION);\n        }\n\n        uint256 balance = rewardToken.balanceOf(address(this));\n        require(rewardRate <= balance.div(REWARD_DURATION), \"Reward too high\");\n\n        lastUpdateTime = block.timestamp;\n        periodFinish = block.timestamp.add(REWARD_DURATION);\n        emit RewardAdded(rewardAmount);\n    }\n\n    /// @dev Claim reward earned so far.\n    function claimReward(address account) external override nonReentrant {\n        _updateReward(account);\n        uint256 reward = rewards[account];\n        if (reward != 0) {\n            rewards[account] = 0;\n            rewardToken.safeTransfer(account, reward);\n            emit RewardPaid(account, reward);\n        }\n    }\n\n    /**\n     * @dev Updated reward for given account. Only Pool can call\n     */\n    function updateReward(address _account) external override {\n        require(msg.sender == pool, \"Only pool can update reward\");\n        _updateReward(_account);\n    }\n\n    function rewardForDuration() external view override returns (uint256) {\n        return rewardRate.mul(REWARD_DURATION);\n    }\n\n    /// @dev Returns claimable reward amount.\n    function claimable(address account) public view override returns (uint256) {\n        return\n            IERC20(pool)\n                .balanceOf(account)\n                .mul(rewardPerToken().sub(userRewardPerTokenPaid[account]))\n                .div(1e18)\n                .add(rewards[account]);\n    }\n\n    /// @dev Returns timestamp of last reward update\n    function lastTimeRewardApplicable() public view override returns (uint256) {\n        return block.timestamp < periodFinish ? block.timestamp : periodFinish;\n    }\n\n    function rewardPerToken() public view override returns (uint256) {\n        if (IERC20(pool).totalSupply() == 0) {\n            return rewardPerTokenStored;\n        }\n        return\n            rewardPerTokenStored.add(\n                lastTimeRewardApplicable().sub(lastUpdateTime).mul(rewardRate).mul(1e18).div(\n                    IERC20(pool).totalSupply()\n                )\n            );\n    }\n\n    function _updateReward(address _account) private {\n        rewardPerTokenStored = rewardPerToken();\n        lastUpdateTime = lastTimeRewardApplicable();\n        if (_account != address(0)) {\n            rewards[_account] = claimable(_account);\n            userRewardPerTokenPaid[_account] = rewardPerTokenStored;\n        }\n    }\n}\n"
    },
    "contracts/strategies/CollateralManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"../interfaces//maker/IMakerDAO.sol\";\nimport \"../interfaces/vesper/ICollateralManager.sol\";\nimport \"../interfaces/vesper/IController.sol\";\n\ncontract DSMath {\n    uint256 internal constant RAY = 10**27;\n    uint256 internal constant WAD = 10**18;\n\n    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require((z = x + y) >= x, \"math-not-safe\");\n    }\n\n    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require((z = x - y) <= x, \"sub-overflow\");\n    }\n\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require(y == 0 || (z = x * y) / y == x, \"math-not-safe\");\n    }\n\n    function wmul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = add(mul(x, y), WAD / 2) / WAD;\n    }\n\n    function wdiv(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = add(mul(x, WAD), y / 2) / y;\n    }\n\n    function rmul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = add(mul(x, y), RAY / 2) / RAY;\n    }\n\n    function toInt(uint256 x) internal pure returns (int256 y) {\n        y = int256(x);\n        require(y >= 0, \"int-overflow\");\n    }\n\n    function toRad(uint256 wad) internal pure returns (uint256 rad) {\n        rad = mul(wad, RAY);\n    }\n\n    /**\n     * @notice It will work only if _dec < 18\n     */\n    function convertTo18(uint256 _dec, uint256 _amt) internal pure returns (uint256 amt) {\n        amt = mul(_amt, 10**(18 - _dec));\n    }\n}\n\ncontract CollateralManager is ICollateralManager, DSMath, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n    mapping(uint256 => address) public override vaultOwner;\n    mapping(bytes32 => address) public mcdGemJoin;\n    mapping(uint256 => bytes32) public vaultType;\n    address public constant DAI = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\n    address public override mcdManager = 0x5ef30b9986345249bc32d8928B7ee64DE9435E39;\n    address public mcdDaiJoin = 0x9759A6Ac90977b93B58547b4A71c78317f391A28;\n    address public mcdSpot = 0x65C79fcB50Ca1594B025960e539eD7A9a6D434A3;\n    address public mcdJug = 0x19c0976f590D67707E62397C87829d896Dc0f1F1;\n    uint256 internal constant MAX_UINT_VALUE = type(uint256).max;\n    IController public immutable controller;\n\n    modifier onlyVaultOwner(uint256 vaultNum) {\n        require(msg.sender == vaultOwner[vaultNum], \"Not a vault owner\");\n        _;\n    }\n\n    modifier onlyController() {\n        require(msg.sender == address(controller), \"Not a controller\");\n        _;\n    }\n\n    constructor(address _controller) public {\n        require(_controller != address(0), \"_controller is zero\");\n        controller = IController(_controller);\n    }\n\n    /**\n     * @dev Add gemJoin adapter address from Maker in mapping\n     * @param gemJoins Array of gem join addresses\n     */\n    function addGemJoin(address[] calldata gemJoins) external override onlyController {\n        require(gemJoins.length != 0, \"No gemJoin address\");\n        for (uint256 i; i < gemJoins.length; i++) {\n            address gemJoin = gemJoins[i];\n            bytes32 ilk = GemJoinLike(gemJoin).ilk();\n            mcdGemJoin[ilk] = gemJoin;\n        }\n    }\n\n    /**\n     * @dev Store vault info.\n     * @param vaultNum Vault number.\n     * @param collateralType Collateral type of vault.\n     */\n    function registerVault(uint256 vaultNum, bytes32 collateralType) external override {\n        require(msg.sender == ManagerLike(mcdManager).owns(vaultNum), \"Not a vault owner\");\n        vaultOwner[vaultNum] = msg.sender;\n        vaultType[vaultNum] = collateralType;\n    }\n\n    /**\n     * @dev Update MCD addresses.\n     */\n    function updateMCDAddresses(\n        address _mcdManager,\n        address _mcdDaiJoin,\n        address _mcdSpot,\n        address _mcdJug\n    ) external onlyController {\n        mcdManager = _mcdManager;\n        mcdDaiJoin = _mcdDaiJoin;\n        mcdSpot = _mcdSpot;\n        mcdJug = _mcdJug;\n    }\n\n    /**\n     * @dev Deposit ERC20 collateral.\n     * @param vaultNum Vault number.\n     * @param amount ERC20 amount to deposit.\n     */\n    function depositCollateral(uint256 vaultNum, uint256 amount)\n        external\n        override\n        nonReentrant\n        onlyVaultOwner(vaultNum)\n    {\n        // Receives Gem amount, approve and joins it into the vat.\n        // Also convert amount to 18 decimal\n        amount = joinGem(mcdGemJoin[vaultType[vaultNum]], amount);\n\n        ManagerLike manager = ManagerLike(mcdManager);\n        // Locks Gem amount into the CDP\n        VatLike(manager.vat()).frob(\n            vaultType[vaultNum],\n            manager.urns(vaultNum),\n            address(this),\n            address(this),\n            toInt(amount),\n            0\n        );\n    }\n\n    /**\n     * @dev Withdraw collateral.\n     * @param vaultNum Vault number.\n     * @param amount Collateral amount to withdraw.\n     */\n    function withdrawCollateral(uint256 vaultNum, uint256 amount)\n        external\n        override\n        nonReentrant\n        onlyVaultOwner(vaultNum)\n    {\n        ManagerLike manager = ManagerLike(mcdManager);\n        GemJoinLike gemJoin = GemJoinLike(mcdGemJoin[vaultType[vaultNum]]);\n\n        uint256 amount18 = convertTo18(gemJoin.dec(), amount);\n\n        // Unlocks Gem amount18 from the CDP\n        manager.frob(vaultNum, -toInt(amount18), 0);\n\n        // Moves Gem amount18 from the CDP urn to this address\n        manager.flux(vaultNum, address(this), amount18);\n\n        // Exits Gem amount to this address as a token\n        gemJoin.exit(address(this), amount);\n\n        // Send Gem to pool's address\n        IERC20(gemJoin.gem()).safeTransfer(vaultOwner[vaultNum], amount);\n    }\n\n    /**\n     * @dev Payback borrowed DAI.\n     * @param vaultNum Vault number.\n     * @param amount Dai amount to payback.\n     */\n    function payback(uint256 vaultNum, uint256 amount) external override onlyVaultOwner(vaultNum) {\n        ManagerLike manager = ManagerLike(mcdManager);\n        address urn = manager.urns(vaultNum);\n        address vat = manager.vat();\n        bytes32 ilk = vaultType[vaultNum];\n\n        // Calculate dai debt\n        uint256 _daiDebt = _getVaultDebt(ilk, urn, vat);\n        require(_daiDebt >= amount, \"paying-excess-debt\");\n\n        // Approve and join dai in vat\n        joinDai(urn, amount);\n        manager.frob(vaultNum, 0, _getWipeAmount(ilk, urn, vat));\n    }\n\n    /**\n     * @notice Borrow DAI.\n     * @dev In edge case, when we hit DAI mint limit, we might end up borrowing\n     * less than what is being asked.\n     * @param vaultNum Vault number.\n     * @param amount Dai amount to borrow. Actual borrow amount may be less than \"amount\"\n     */\n    function borrow(uint256 vaultNum, uint256 amount) external override onlyVaultOwner(vaultNum) {\n        ManagerLike manager = ManagerLike(mcdManager);\n        address vat = manager.vat();\n        // Safety check in scenario where current debt and request borrow will exceed max dai limit\n        uint256 _maxAmount = maxAvailableDai(vat, vaultNum);\n        if (amount > _maxAmount) {\n            amount = _maxAmount;\n        }\n\n        // Generates debt in the CDP\n        manager.frob(vaultNum, 0, _getBorrowAmount(vat, manager.urns(vaultNum), vaultNum, amount));\n        // Moves the DAI amount (balance in the vat in rad) to pool's address\n        manager.move(vaultNum, address(this), toRad(amount));\n        // Allows adapter to access to pool's DAI balance in the vat\n        if (VatLike(vat).can(address(this), mcdDaiJoin) == 0) {\n            VatLike(vat).hope(mcdDaiJoin);\n        }\n        // Exits DAI as a token to user's address\n        DaiJoinLike(mcdDaiJoin).exit(msg.sender, amount);\n    }\n\n    /// @dev sweep given ERC20 token to treasury pool\n    function sweepErc20(address fromToken) external {\n        uint256 amount = IERC20(fromToken).balanceOf(address(this));\n        address treasuryPool = controller.treasuryPool();\n        IERC20(fromToken).safeTransfer(treasuryPool, amount);\n    }\n\n    /**\n     * @dev Get current dai debt of vault.\n     * @param vaultNum Vault number.\n     */\n    function getVaultDebt(uint256 vaultNum) external view override returns (uint256 daiDebt) {\n        address urn = ManagerLike(mcdManager).urns(vaultNum);\n        address vat = ManagerLike(mcdManager).vat();\n        bytes32 ilk = vaultType[vaultNum];\n\n        daiDebt = _getVaultDebt(ilk, urn, vat);\n    }\n\n    /**\n     * @dev Get current collateral balance of vault.\n     * @param vaultNum Vault number.\n     */\n    function getVaultBalance(uint256 vaultNum)\n        external\n        view\n        override\n        returns (uint256 collateralLocked)\n    {\n        address vat = ManagerLike(mcdManager).vat();\n        address urn = ManagerLike(mcdManager).urns(vaultNum);\n        (collateralLocked, ) = VatLike(vat).urns(vaultType[vaultNum], urn);\n    }\n\n    /**\n     * @dev Calculate state based on withdraw amount.\n     * @param vaultNum Vault number.\n     * @param amount Collateral amount to withraw.\n     */\n    function whatWouldWithdrawDo(uint256 vaultNum, uint256 amount)\n        external\n        view\n        override\n        returns (\n            uint256 collateralLocked,\n            uint256 daiDebt,\n            uint256 collateralUsdRate,\n            uint256 collateralRatio,\n            uint256 minimumDebt\n        )\n    {\n        (collateralLocked, daiDebt, collateralUsdRate, collateralRatio, minimumDebt) = getVaultInfo(\n            vaultNum\n        );\n\n        GemJoinLike gemJoin = GemJoinLike(mcdGemJoin[vaultType[vaultNum]]);\n        uint256 amount18 = convertTo18(gemJoin.dec(), amount);\n        require(amount18 <= collateralLocked, \"insufficient collateral locked\");\n        collateralLocked = sub(collateralLocked, amount18);\n        collateralRatio = getCollateralRatio(collateralLocked, collateralUsdRate, daiDebt);\n    }\n\n    /**\n     * @dev Get vault info\n     * @param vaultNum Vault number.\n     */\n    function getVaultInfo(uint256 vaultNum)\n        public\n        view\n        override\n        returns (\n            uint256 collateralLocked,\n            uint256 daiDebt,\n            uint256 collateralUsdRate,\n            uint256 collateralRatio,\n            uint256 minimumDebt\n        )\n    {\n        (collateralLocked, collateralUsdRate, daiDebt, minimumDebt) = _getVaultInfo(vaultNum);\n        collateralRatio = getCollateralRatio(collateralLocked, collateralUsdRate, daiDebt);\n    }\n\n    /**\n     * @dev Get available DAI amount based on current DAI debt and limit for given vault type.\n     * @param vat Vat address\n     * @param vaultNum Vault number.\n     */\n    function maxAvailableDai(address vat, uint256 vaultNum) public view returns (uint256) {\n        // Get stable coin Art(debt) [wad], rate [ray], line [rad]\n        //solhint-disable-next-line var-name-mixedcase\n        (uint256 Art, uint256 rate, , uint256 line, ) = VatLike(vat).ilks(vaultType[vaultNum]);\n        // Calculate total issued debt is Art * rate [rad]\n        // Calcualte total available dai [wad]\n        uint256 _totalAvailableDai = sub(line, mul(Art, rate)) / RAY;\n        // For safety reason, return 99% of available\n        return mul(_totalAvailableDai, 99) / 100;\n    }\n\n    function joinDai(address urn, uint256 amount) internal {\n        DaiJoinLike daiJoin = DaiJoinLike(mcdDaiJoin);\n        // Transfer Dai from strategy or pool to here\n        IERC20(DAI).safeTransferFrom(msg.sender, address(this), amount);\n        // Approves adapter to move dai.\n        IERC20(DAI).safeApprove(mcdDaiJoin, 0);\n        IERC20(DAI).safeApprove(mcdDaiJoin, amount);\n        // Joins DAI into the vat\n        daiJoin.join(urn, amount);\n    }\n\n    function joinGem(address adapter, uint256 amount) internal returns (uint256) {\n        GemJoinLike gemJoin = GemJoinLike(adapter);\n\n        IERC20 token = IERC20(gemJoin.gem());\n        // Transfer token from strategy or pool to here\n        token.safeTransferFrom(msg.sender, address(this), amount);\n        // Approves adapter to take the Gem amount\n        token.safeApprove(adapter, 0);\n        token.safeApprove(adapter, amount);\n        // Joins Gem collateral into the vat\n        gemJoin.join(address(this), amount);\n        // Convert amount to 18 decimal\n        return convertTo18(gemJoin.dec(), amount);\n    }\n\n    /**\n     * @dev Get borrow dai amount.\n     */\n    function _getBorrowAmount(\n        address vat,\n        address urn,\n        uint256 vaultNum,\n        uint256 wad\n    ) internal returns (int256 amount) {\n        // Updates stability fee rate\n        uint256 rate = JugLike(mcdJug).drip(vaultType[vaultNum]);\n\n        // Gets DAI balance of the urn in the vat\n        uint256 dai = VatLike(vat).dai(urn);\n\n        // If there was already enough DAI in the vat balance, just exits it without adding more debt\n        if (dai < mul(wad, RAY)) {\n            // Calculates the needed amt so together with the existing dai in the vat is enough to exit wad amount of DAI tokens\n            amount = toInt(sub(mul(wad, RAY), dai) / rate);\n            // This is neeeded due lack of precision. It might need to sum an extra amt wei (for the given DAI wad amount)\n            amount = mul(uint256(amount), rate) < mul(wad, RAY) ? amount + 1 : amount;\n        }\n    }\n\n    /**\n     * @dev Get collateral ratio\n     */\n    function getCollateralRatio(\n        uint256 collateralLocked,\n        uint256 collateralRate,\n        uint256 daiDebt\n    ) internal pure returns (uint256) {\n        if (collateralLocked == 0) {\n            return 0;\n        }\n\n        if (daiDebt == 0) {\n            return MAX_UINT_VALUE;\n        }\n\n        require(collateralRate != 0, \"Collateral rate is zero\");\n        return wdiv(wmul(collateralLocked, collateralRate), daiDebt);\n    }\n\n    /**\n     * @dev Get Vault Debt Amount.\n     */\n    function _getVaultDebt(\n        bytes32 ilk,\n        address urn,\n        address vat\n    ) internal view returns (uint256 wad) {\n        // Get normalised debt [wad]\n        (, uint256 art) = VatLike(vat).urns(ilk, urn);\n        // Get stable coin rate [ray]\n        (, uint256 rate, , , ) = VatLike(vat).ilks(ilk);\n        // Get balance from vat [rad]\n        uint256 dai = VatLike(vat).dai(urn);\n\n        wad = _getVaultDebt(art, rate, dai);\n    }\n\n    function _getVaultDebt(\n        uint256 art,\n        uint256 rate,\n        uint256 dai\n    ) internal pure returns (uint256 wad) {\n        if (dai < mul(art, rate)) {\n            uint256 rad = sub(mul(art, rate), dai);\n            wad = rad / RAY;\n            wad = mul(wad, RAY) < rad ? wad + 1 : wad;\n        } else {\n            wad = 0;\n        }\n    }\n\n    function _getVaultInfo(uint256 vaultNum)\n        internal\n        view\n        returns (\n            uint256 collateralLocked,\n            uint256 collateralUsdRate,\n            uint256 daiDebt,\n            uint256 minimumDebt\n        )\n    {\n        address urn = ManagerLike(mcdManager).urns(vaultNum);\n        address vat = ManagerLike(mcdManager).vat();\n        bytes32 ilk = vaultType[vaultNum];\n\n        // Get minimum liquidation ratio [ray]\n        (, uint256 mat) = SpotterLike(mcdSpot).ilks(ilk);\n\n        // Get collateral locked and normalised debt [wad] [wad]\n        (uint256 ink, uint256 art) = VatLike(vat).urns(ilk, urn);\n        // Get stable coin and collateral rate  and min debt [ray] [ray] [rad]\n        (, uint256 rate, uint256 spot, , uint256 dust) = VatLike(vat).ilks(ilk);\n        // Get balance from vat [rad]\n\n        collateralLocked = ink;\n        daiDebt = _getVaultDebt(art, rate, VatLike(vat).dai(urn));\n        minimumDebt = dust / RAY;\n        // Calculate collateral rate in 18 decimals\n        collateralUsdRate = rmul(mat, spot) / 10**9;\n    }\n\n    /**\n     * @dev Get Payback amount.\n     * @notice We need to fetch latest art, rate and dai to calcualte payback amount.\n     */\n    function _getWipeAmount(\n        bytes32 ilk,\n        address urn,\n        address vat\n    ) internal view returns (int256 amount) {\n        // Get normalize debt, rate and dai balance from Vat\n        (, uint256 art) = VatLike(vat).urns(ilk, urn);\n        (, uint256 rate, , , ) = VatLike(vat).ilks(ilk);\n        uint256 dai = VatLike(vat).dai(urn);\n\n        // Uses the whole dai balance in the vat to reduce the debt\n        amount = toInt(dai / rate);\n        // Checks the calculated amt is not higher than urn.art (total debt), otherwise uses its value\n        amount = uint256(amount) <= art ? -amount : -toInt(art);\n    }\n}\n"
    },
    "contracts/interfaces/maker/IMakerDAO.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\ninterface ManagerLike {\n    function cdpCan(\n        address,\n        uint256,\n        address\n    ) external view returns (uint256);\n\n    function ilks(uint256) external view returns (bytes32);\n\n    function owns(uint256) external view returns (address);\n\n    function urns(uint256) external view returns (address);\n\n    function vat() external view returns (address);\n\n    function open(bytes32, address) external returns (uint256);\n\n    function give(uint256, address) external;\n\n    function cdpAllow(\n        uint256,\n        address,\n        uint256\n    ) external;\n\n    function urnAllow(address, uint256) external;\n\n    function frob(\n        uint256,\n        int256,\n        int256\n    ) external;\n\n    function flux(\n        uint256,\n        address,\n        uint256\n    ) external;\n\n    function move(\n        uint256,\n        address,\n        uint256\n    ) external;\n\n    function exit(\n        address,\n        uint256,\n        address,\n        uint256\n    ) external;\n\n    function quit(uint256, address) external;\n\n    function enter(address, uint256) external;\n\n    function shift(uint256, uint256) external;\n}\n\ninterface VatLike {\n    function can(address, address) external view returns (uint256);\n\n    function ilks(bytes32)\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256\n        );\n\n    function dai(address) external view returns (uint256);\n\n    function urns(bytes32, address) external view returns (uint256, uint256);\n\n    function frob(\n        bytes32,\n        address,\n        address,\n        address,\n        int256,\n        int256\n    ) external;\n\n    function hope(address) external;\n\n    function nope(address) external;\n\n    function move(\n        address,\n        address,\n        uint256\n    ) external;\n}\n\ninterface GemJoinLike {\n    function dec() external view returns (uint256);\n\n    function gem() external view returns (address);\n\n    function ilk() external view returns (bytes32);\n\n    function join(address, uint256) external payable;\n\n    function exit(address, uint256) external;\n}\n\ninterface DaiJoinLike {\n    function vat() external returns (VatLike);\n\n    function dai() external view returns (address);\n\n    function join(address, uint256) external payable;\n\n    function exit(address, uint256) external;\n}\n\ninterface JugLike {\n    function drip(bytes32) external returns (uint256);\n}\n\ninterface SpotterLike {\n    function ilks(bytes32) external view returns (address, uint256);\n}\n"
    },
    "contracts/strategies/AaveV2Strategy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"./Strategy.sol\";\nimport \"./AaveRewards.sol\";\nimport \"../interfaces/aave/IAaveV2.sol\";\nimport \"../interfaces/vesper/IVesperPool.sol\";\n\n/// @dev This strategy will deposit collateral token in Aave and earn interest.\nabstract contract AaveV2Strategy is Strategy, AaveRewards {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    //solhint-disable-next-line const-name-snakecase\n    AaveLendingPoolAddressesProvider public constant aaveAddressesProvider =\n        AaveLendingPoolAddressesProvider(0xB53C1a33016B2DC2fF3653530bfF1848a515c8c5);\n\n    uint256 public pendingFee;\n    IERC20 internal immutable aToken;\n    uint256 internal collateralLocked;\n\n    constructor(\n        address _controller,\n        address _pool,\n        address _receiptToken\n    ) public Strategy(_controller, _pool, _receiptToken) {\n        aToken = IERC20(_receiptToken);\n    }\n\n    //solhint-disable no-empty-blocks\n    function beforeWithdraw() external override onlyPool {}\n\n    /**\n     * @notice Returns interest earned since last rebalance.\n     * @dev Make sure to return value in collateral token\n     */\n    function interestEarned() external view override returns (uint256 collateralEarned) {\n        uint256 _aaveAmount = stkAAVE.getTotalRewardsBalance(address(this));\n        if (_aaveAmount != 0) {\n            (, collateralEarned, ) = swapManager.bestOutputFixedInput(\n                AAVE,\n                address(collateralToken),\n                _aaveAmount\n            );\n        }\n    }\n\n    /// @notice Initiate cooldown to unstake aave.\n    function startCooldown() external onlyKeeper returns (bool) {\n        return _startCooldown();\n    }\n\n    /// @notice Unstake Aave from stakedAave contract\n    function unstakeAave() external onlyKeeper {\n        _unstakeAave();\n    }\n\n    /**\n     * @dev Deposit available collateral from pool into Aave.\n     * Also calculate interest fee on earning from Aave and transfer fee to fee collector.\n     * Anyone can call it except when paused.\n     */\n    function rebalance() external override onlyKeeper {\n        _rebalanceEarned();\n        uint256 balance = collateralToken.balanceOf(pool);\n        if (balance != 0) {\n            _deposit(balance);\n        }\n    }\n\n    /// @dev Returns true if strategy can be upgraded.\n    /// @dev If there are no aTokens in strategy then it is upgradable\n    function isUpgradable() external view override returns (bool) {\n        return aToken.balanceOf(address(this)) == 0;\n    }\n\n    function isReservedToken(address _token) public view override returns (bool) {\n        return _token == receiptToken || _token == AAVE || _token == address(stkAAVE);\n    }\n\n    /**\n     * @notice Total collateral locked in Aave.\n     * @dev This value will be used in pool share calculation, so true totalLocked\n     * will be balance in Aave minus any pending fee to collect.\n     * @return Return value will be in collateralToken defined decimal.\n     */\n    function totalLocked() public view override returns (uint256) {\n        uint256 balance = aToken.balanceOf(pool).add(aToken.balanceOf(address(this)));\n        return balance.sub(_calculatePendingFee(balance));\n    }\n\n    /// @notice Large approval of token\n    function _approveToken(uint256 _amount) internal override {\n        collateralToken.safeApprove(pool, _amount);\n        collateralToken.safeApprove(aaveAddressesProvider.getLendingPool(), _amount);\n        for (uint256 i = 0; i < swapManager.N_DEX(); i++) {\n            IERC20(AAVE).safeApprove(address(swapManager.ROUTERS(i)), _amount);\n        }\n    }\n\n    /**\n     * @dev Claim Aave and convert it into collateral token.\n     * Calculate interest fee on earning from Aave and transfer balance minus\n     * fee to pool.\n     * @dev Transferring collateral to pool will increase pool share price.\n     */\n    function _claimReward() internal override {\n        uint256 _aaveAmount = _claimAave();\n        if (_aaveAmount != 0) {\n            _safeSwap(AAVE, address(collateralToken), _aaveAmount);\n            uint256 _collateralEarned = collateralToken.balanceOf(address(this));\n            uint256 _fee = _collateralEarned.mul(controller.interestFee(pool)).div(1e18);\n            collateralToken.safeTransfer(pool, _collateralEarned.sub(_fee));\n        }\n    }\n\n    function _deposit(uint256 _amount) internal virtual override {\n        collateralToken.safeTransferFrom(pool, address(this), _amount);\n        address _aaveLendingPool = aaveAddressesProvider.getLendingPool();\n\n        AaveLendingPool(_aaveLendingPool).deposit(\n            address(collateralToken),\n            _amount,\n            address(this),\n            0\n        );\n        _updateCollateralLocked();\n    }\n\n    /**\n     * @notice Migrate tokens from pool to this address\n     * @dev Any working Aave strategy has aToken in strategy contract.\n     * @dev There can be scenarios when pool already has aTokens and new\n     * strategy will have to move those tokens from pool to self address.\n     * @dev Only valid pool strategy is allowed to move tokens from pool.\n     */\n    function _migrateIn() internal override {\n        require(controller.isPool(pool), \"not-a-valid-pool\");\n        require(controller.strategy(pool) == address(this), \"not-a-valid-strategy\");\n        aToken.safeTransferFrom(pool, address(this), aToken.balanceOf(pool));\n    }\n\n    /**\n     * @notice Migrate tokens out to pool.\n     * @dev There can be scenarios when we want to use new strategy without\n     * calling withdrawAll(). We can achieve this by moving tokens in pool\n     * and new strategy will take care from there.\n     * @dev Pause this strategy, set pendingFee to zero and move tokens out.\n     */\n    function _migrateOut() internal override {\n        require(controller.isPool(pool), \"not-a-valid-pool\");\n        _pause();\n        pendingFee = 0;\n        aToken.safeTransfer(pool, aToken.balanceOf(address(this)));\n        IERC20(stkAAVE).safeTransfer(pool, stkAAVE.balanceOf(address(this)));\n    }\n\n    /**\n     * @dev Calcualte earning from Aave and also calculate interest fee.\n     * Deposit fee into Vesper pool to get Vesper pool shares.\n     * Transfer fee, Vesper pool shares, to fee collector\n     */\n    function _rebalanceEarned() internal {\n        _updatePendingFee();\n        _claimReward();\n        if (pendingFee != 0) {\n            // Withdraw pendingFee worth collateral from Aave\n            _withdraw(pendingFee, address(this));\n            pendingFee = 0;\n        }\n        _handleFee(collateralToken.balanceOf(address(this)));\n    }\n\n    /**\n     * @dev Withdraw collateral token from Aave.\n     * @param _amount Amount of collateral token\n     */\n    function _withdraw(uint256 _amount) internal override {\n        _withdraw(_amount, pool);\n    }\n\n    /**\n     * @dev Withdraw amount from Aave to given address\n     * @param _amount Amount of aToken to withdraw\n     * @param _to Address where you want receive collateral\n     */\n    function _withdraw(uint256 _amount, address _to) internal virtual {\n        address aavePool = aaveAddressesProvider.getLendingPool();\n        require(\n            AaveLendingPool(aavePool).withdraw(address(collateralToken), _amount, _to) == _amount,\n            \"withdrawn-amount-is-not-correct\"\n        );\n        _updateCollateralLocked();\n    }\n\n    /**\n     * @dev Withdraw all collateral from Aave and deposit into pool.\n     * Controller only function, called when migrating strategy.\n     */\n    function _withdrawAll() internal override {\n        uint256 _balance = aToken.balanceOf(address(this));\n        if (_balance != 0) {\n            pendingFee = 0;\n            _withdraw(_balance, pool);\n        }\n    }\n\n    function _updateCollateralLocked() internal {\n        collateralLocked = aToken.balanceOf(address(this));\n    }\n\n    function _updatePendingFee() internal override {\n        pendingFee = _calculatePendingFee(aToken.balanceOf(address(this)));\n    }\n\n    function _calculatePendingFee(uint256 aTokenBalance) internal view returns (uint256) {\n        uint256 interest = aTokenBalance.sub(collateralLocked);\n        uint256 fee = interest.mul(controller.interestFee(pool)).div(1e18);\n        return pendingFee.add(fee);\n    }\n}\n"
    },
    "contracts/strategies/AaveRewards.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"../interfaces/aave/IAaveV2.sol\";\n\n/// @title This contract provide utility functions to claim Aave rewards\nabstract contract AaveRewards {\n    //solhint-disable-next-line const-name-snakecase\n    StakedAave public constant stkAAVE = StakedAave(0x4da27a545c0c5B758a6BA100e3a049001de870f5);\n    address public constant AAVE = 0x7Fc66500c84A76Ad7e9c93437bFc5Ac33E2DDaE9;\n\n    /// @notice Returns true if Aave can be unstaked\n    function canUnstake() external view returns (bool) {\n        (, uint256 _cooldownEnd, uint256 _unstakeEnd) = cooldownData();\n        return _canUnstake(_cooldownEnd, _unstakeEnd);\n    }\n\n    /// @notice Returns true if we should start cooldown\n    function canStartCooldown() public view returns (bool) {\n        (uint256 _cooldownStart, , uint256 _unstakeEnd) = cooldownData();\n        return _canStartCooldown(_cooldownStart, _unstakeEnd);\n    }\n\n    /// @notice Return cooldown related timestamps\n    function cooldownData()\n        public\n        view\n        returns (\n            uint256 _cooldownStart,\n            uint256 _cooldownEnd,\n            uint256 _unstakeEnd\n        )\n    {\n        _cooldownStart = stkAAVE.stakersCooldowns(address(this));\n        _cooldownEnd = _cooldownStart + stkAAVE.COOLDOWN_SECONDS();\n        _unstakeEnd = _cooldownEnd + stkAAVE.UNSTAKE_WINDOW();\n    }\n\n    /**\n     * @notice Claim Aave. Also unstake all Aave if favorable condition exits or start cooldown.\n     * @dev If we unstake all Aave, we can't start cooldown because it requires StakedAave balance.\n     * @dev DO NOT convert 'if else' to 2 'if's as we are reading cooldown state once to save gas.\n     */\n    function _claimAave() internal returns (uint256) {\n        (uint256 _cooldownStart, uint256 _cooldownEnd, uint256 _unstakeEnd) = cooldownData();\n\n        if (_canUnstake(_cooldownEnd, _unstakeEnd)) {\n            stkAAVE.redeem(address(this), type(uint256).max);\n        } else if (_canStartCooldown(_cooldownStart, _unstakeEnd)) {\n            stkAAVE.cooldown();\n        }\n\n        stkAAVE.claimRewards(address(this), type(uint256).max);\n        return IERC20(AAVE).balanceOf(address(this));\n    }\n\n    /**\n     * @notice Initiate cooldown to unstake aave.\n     * @dev We only want to call this function when cooldown is expired and\n     * that's the reason we have 'if' condition.\n     */\n    function _startCooldown() internal returns (bool) {\n        if (canStartCooldown()) {\n            stkAAVE.cooldown();\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * @notice Unstake Aave from stakedAave contract\n     * @dev We want to unstake as soon as favorable condition exit\n     * @dev No guarding condtion thus this call can fail, if we can't unstake.\n     */\n    function _unstakeAave() internal {\n        stkAAVE.redeem(address(this), type(uint256).max);\n    }\n\n    /**\n     * @dev Return true, only if we have StakedAave balance and either cooldown expired or cooldown is zero\n     * @dev If we are in cooldown period we cannot unstake Aave. But our cooldown is still valid so we do\n     * not want to reset/start cooldown.\n     */\n    function _canStartCooldown(uint256 _cooldownStart, uint256 _unstakeEnd)\n        internal\n        view\n        returns (bool)\n    {\n        return\n            stkAAVE.balanceOf(address(this)) != 0 &&\n            (_cooldownStart == 0 || block.timestamp > _unstakeEnd);\n    }\n\n    /// @dev Return true, if cooldown is over and we are in unstake window.\n    function _canUnstake(uint256 _cooldownEnd, uint256 _unstakeEnd) internal view returns (bool) {\n        return block.timestamp > _cooldownEnd && block.timestamp <= _unstakeEnd;\n    }\n\n    /// @dev Check whether given token is reserved or not. Reserved tokens are not allowed to sweep.\n    function _isReservedToken(address _token) internal pure returns (bool) {\n        return _token == AAVE || _token == address(stkAAVE);\n    }\n}\n"
    },
    "contracts/interfaces/aave/IAaveV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface AaveLendingPoolAddressesProvider {\n    function getLendingPool() external view returns (address);\n\n    function getAddress(bytes32 id) external view returns (address);\n}\n\ninterface AaveLendingPool {\n    function deposit(\n        address asset,\n        uint256 amount,\n        address onBehalfOf,\n        uint16 referralCode\n    ) external;\n\n    function withdraw(\n        address asset,\n        uint256 amount,\n        address to\n    ) external returns (uint256);\n}\n\ninterface AaveProtocolDataProvider {\n    function getReserveTokensAddresses(address asset)\n        external\n        view\n        returns (\n            address aTokenAddress,\n            address stableDebtTokenAddress,\n            address variableDebtTokenAddress\n        );\n}\n\n//solhint-disable func-name-mixedcase\ninterface StakedAave is IERC20 {\n    function claimRewards(address to, uint256 amount) external;\n\n    function cooldown() external;\n\n    function redeem(address to, uint256 amount) external;\n\n    function getTotalRewardsBalance(address staker) external view returns (uint256);\n\n    function stakersCooldowns(address staker) external view returns (uint256);\n\n    function COOLDOWN_SECONDS() external view returns (uint256);\n\n    function UNSTAKE_WINDOW() external view returns (uint256);\n}\n"
    },
    "contracts/strategies/AaveV2StrategyWBTC.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"./AaveV2Strategy.sol\";\n\n//solhint-disable no-empty-blocks\ncontract AaveV2StrategyWBTC is AaveV2Strategy {\n    string public constant NAME = \"Strategy-AaveV2-WBTC\";\n    string public constant VERSION = \"2.0.3\";\n\n    constructor(address _controller, address _pool)\n        public\n        AaveV2Strategy(_controller, _pool, 0x9ff58f4fFB29fA2266Ab25e75e2A8b3503311656) // aWBTC\n    {}\n}\n"
    },
    "contracts/strategies/AaveV2StrategyUSDC.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"./AaveV2Strategy.sol\";\n\n//solhint-disable no-empty-blocks\ncontract AaveV2StrategyUSDC is AaveV2Strategy {\n    string public constant NAME = \"Strategy-AaveV2-USDC\";\n    string public constant VERSION = \"2.0.2\";\n\n    constructor(address _controller, address _pool)\n        public\n        AaveV2Strategy(_controller, _pool, 0xBcca60bB61934080951369a648Fb03DF4F96263C) //aUSDC\n    {}\n}\n"
    },
    "contracts/strategies/AaveV2StrategyLINK.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"./AaveV2Strategy.sol\";\n\n//solhint-disable no-empty-blocks\ncontract AaveV2StrategyLINK is AaveV2Strategy {\n    string public constant NAME = \"Strategy-AaveV2-LINK\";\n    string public constant VERSION = \"2.0.3\";\n\n    constructor(address _controller, address _pool)\n        public\n        AaveV2Strategy(_controller, _pool, 0xa06bC25B5805d5F8d82847D191Cb4Af5A3e873E0) //aLink\n    {}\n}\n"
    },
    "contracts/strategies/AaveV2StrategyETH.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"./AaveV2Strategy.sol\";\nimport \"../interfaces/token/IToken.sol\";\n\n//solhint-disable no-empty-blocks\ncontract AaveV2StrategyETH is AaveV2Strategy {\n    string public constant NAME = \"Strategy-AaveV2-ETH\";\n    string public constant VERSION = \"2.0.3\";\n\n    constructor(address _controller, address _pool)\n        public\n        AaveV2Strategy(_controller, _pool, 0x030bA81f1c18d280636F32af80b9AAd02Cf0854e) // aWETH\n    {}\n}\n"
    },
    "contracts/strategies/AaveV2StrategyDAI.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"./AaveV2Strategy.sol\";\n\n//solhint-disable no-empty-blocks\ncontract AaveV2StrategyDAI is AaveV2Strategy {\n    string public constant NAME = \"Strategy-AaveV2-DAI\";\n    string public constant VERSION = \"2.0.3\";\n\n    constructor(address _controller, address _pool)\n        public\n        AaveV2Strategy(_controller, _pool, 0x028171bCA77440897B824Ca71D1c56caC55b68A3) //aDAI\n    {}\n}\n"
    },
    "contracts/strategies/AaveV2MakerStrategy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"./MakerStrategy.sol\";\nimport \"./AaveRewards.sol\";\nimport \"../interfaces/aave/IAaveV2.sol\";\n\n/// @dev This strategy will deposit collateral token in Maker and borrow DAI\n/// and deposit borrowed DAI in Aave to earn interest on it.\nabstract contract AaveV2MakerStrategy is MakerStrategy, AaveRewards {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    //solhint-disable-next-line const-name-snakecase\n    AaveLendingPoolAddressesProvider public constant aaveAddressesProvider =\n        AaveLendingPoolAddressesProvider(0xB53C1a33016B2DC2fF3653530bfF1848a515c8c5);\n\n    uint256 private constant WAT = 10**16;\n    IERC20 private immutable aToken;\n    mapping(address => bool) private reservedToken;\n\n    constructor(\n        address _controller,\n        address _pool,\n        address _cm,\n        address _receiptToken,\n        bytes32 _collateralType\n    ) public MakerStrategy(_controller, _pool, _cm, _receiptToken, _collateralType) {\n        aToken = IERC20(_receiptToken);\n    }\n\n    /// @notice Initiate cooldown to unstake aave.\n    function startCooldown() external onlyKeeper returns (bool) {\n        return _startCooldown();\n    }\n\n    /// @notice Unstake Aave from stakedAave contract\n    function unstakeAave() external onlyKeeper {\n        _unstakeAave();\n    }\n\n    /// @notice Returns interest earned since last rebalance.\n    function interestEarned() public view virtual override returns (uint256 collateralEarned) {\n        collateralEarned = super.interestEarned();\n        uint256 _aaveAmount = stkAAVE.getTotalRewardsBalance(address(this));\n        if (_aaveAmount != 0) {\n            (, uint256 _amountOut, ) =\n                swapManager.bestOutputFixedInput(AAVE, address(collateralToken), _aaveAmount);\n            collateralEarned = collateralEarned.add(_amountOut);\n        }\n    }\n\n    /// @dev Check whether given token is reserved or not. Reserved tokens are not allowed to sweep.\n    function isReservedToken(address _token) public view override returns (bool) {\n        return _token == receiptToken || _token == AAVE || _token == address(stkAAVE);\n    }\n\n    /// @dev Approve Dai and collateralToken to collateral manager\n    function _approveToken(uint256 _amount) internal override {\n        super._approveToken(_amount);\n        IERC20(DAI).safeApprove(aaveAddressesProvider.getLendingPool(), _amount);\n        for (uint256 i = 0; i < swapManager.N_DEX(); i++) {\n            IERC20(AAVE).safeApprove(address(swapManager.ROUTERS(i)), _amount);\n        }\n    }\n\n    function _claimReward() internal override {\n        uint256 _aaveAmount = _claimAave();\n        if (_aaveAmount != 0) {\n            _safeSwap(AAVE, address(collateralToken), _aaveAmount);\n        }\n    }\n\n    function _depositDaiToLender(uint256 _amount) internal override {\n        address _aaveLendingPool = aaveAddressesProvider.getLendingPool();\n        AaveLendingPool(_aaveLendingPool).deposit(DAI, _amount, address(this), 0);\n    }\n\n    function _getDaiBalance() internal view override returns (uint256) {\n        return aToken.balanceOf(address(this));\n    }\n\n    function _withdrawDaiFromLender(uint256 _amount) internal override {\n        address _aaveLendingPool = aaveAddressesProvider.getLendingPool();\n        require(\n            AaveLendingPool(_aaveLendingPool).withdraw(DAI, _amount, address(this)) == _amount,\n            \"withdrawn-amount-is-not-correct\"\n        );\n    }\n\n    /// dev these functions are not implemented for this strategy\n    // solhint-disable-next-line no-empty-blocks\n    function _migrateIn() internal override {}\n\n    // solhint-disable-next-line no-empty-blocks\n    function _migrateOut() internal override {}\n}\n"
    },
    "contracts/strategies/AaveV2MakerStrategyETH.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"./AaveV2MakerStrategy.sol\";\n\n//solhint-disable no-empty-blocks\ncontract AaveV2MakerStrategyETH is AaveV2MakerStrategy {\n    string public constant NAME = \"AaveV2Maker-Strategy-ETH\";\n    string public constant VERSION = \"2.0.3\";\n\n    constructor(\n        address _controller,\n        address _pool,\n        address _cm\n    )\n        public\n        AaveV2MakerStrategy(\n            _controller,\n            _pool,\n            _cm,\n            0x028171bCA77440897B824Ca71D1c56caC55b68A3, //aDAI\n            \"ETH-A\"\n        )\n    {}\n}\n"
    },
    "contracts/governor/PoolShareGovernanceToken.sol": {
      "content": "// SPDX-License-Identifier: BSD 3-Clause\n\n// From https://github.com/compound-finance/compound-protocol/blob/master/contracts/Governance/Comp.sol\n\n// Copyright 2020 Compound Labs, Inc.\n// Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n// 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n// 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n// 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\npragma solidity 0.6.12;\n\nimport \"../pools/PoolShareToken.sol\";\n\n// solhint-disable reason-string, no-empty-blocks\nabstract contract PoolShareGovernanceToken is PoolShareToken {\n    /// @dev A record of each accounts delegate\n    mapping(address => address) public delegates;\n\n    /// @dev A checkpoint for marking number of votes from a given block\n    struct Checkpoint {\n        uint32 fromBlock;\n        uint256 votes;\n    }\n\n    /// @dev A record of votes checkpoints for each account, by index\n    mapping(address => mapping(uint32 => Checkpoint)) public checkpoints;\n\n    /// @dev The number of checkpoints for each account\n    mapping(address => uint32) public numCheckpoints;\n\n    /// @dev The EIP-712 typehash for the delegation struct used by the contract\n    bytes32 public constant DELEGATION_TYPEHASH =\n        keccak256(\"Delegation(address delegatee,uint256 nonce,uint256 expiry)\");\n\n    /// @dev An event thats emitted when an account changes its delegate\n    event DelegateChanged(\n        address indexed delegator,\n        address indexed fromDelegate,\n        address indexed toDelegate\n    );\n\n    /// @dev An event thats emitted when a delegate account's vote balance changes\n    event DelegateVotesChanged(\n        address indexed delegate,\n        uint256 previousBalance,\n        uint256 newBalance\n    );\n\n    /**\n     * @dev Constructor.\n     */\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        address _token,\n        address _controller\n    ) public PoolShareToken(_name, _symbol, _token, _controller) {}\n\n    /**\n     * @dev Delegate votes from `msg.sender` to `delegatee`\n     * @param delegatee The address to delegate votes to\n     */\n    function delegate(address delegatee) external {\n        return _delegate(msg.sender, delegatee);\n    }\n\n    /**\n     * @dev Delegates votes from signatory to `delegatee`\n     * @param delegatee The address to delegate votes to\n     * @param nonce The contract state required to match the signature\n     * @param expiry The time at which to expire the signature\n     * @param v The recovery byte of the signature\n     * @param r Half of the ECDSA signature pair\n     * @param s Half of the ECDSA signature pair\n     */\n    function delegateBySig(\n        address delegatee,\n        uint256 nonce,\n        uint256 expiry,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external {\n        bytes32 domainSeparator =\n            keccak256(\n                abi.encode(\n                    DOMAIN_TYPEHASH,\n                    keccak256(bytes(name())),\n                    keccak256(bytes(\"1\")),\n                    getChainId(),\n                    address(this)\n                )\n            );\n\n        bytes32 structHash = keccak256(abi.encode(DELEGATION_TYPEHASH, delegatee, nonce, expiry));\n\n        bytes32 digest = keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n\n        address signatory = ecrecover(digest, v, r, s);\n        require(signatory != address(0), \"VSP::delegateBySig: invalid signature\");\n        require(nonce == nonces[signatory]++, \"VSP::delegateBySig: invalid nonce\");\n        require(now <= expiry, \"VSP::delegateBySig: signature expired\");\n        return _delegate(signatory, delegatee);\n    }\n\n    /**\n     * @dev Gets the current votes balance for `account`\n     * @param account The address to get votes balance\n     * @return The number of current votes for `account`\n     */\n    function getCurrentVotes(address account) external view returns (uint256) {\n        uint32 nCheckpoints = numCheckpoints[account];\n        return nCheckpoints > 0 ? checkpoints[account][nCheckpoints - 1].votes : 0;\n    }\n\n    /**\n     * @dev Determine the prior number of votes for an account as of a block number\n     * @dev Block number must be a finalized block or else this function will revert to prevent misinformation.\n     * @param account The address of the account to check\n     * @param blockNumber The block number to get the vote balance at\n     * @return The number of votes the account had as of the given block\n     */\n    function getPriorVotes(address account, uint256 blockNumber) external view returns (uint256) {\n        require(blockNumber < block.number, \"VSP::getPriorVotes: not yet determined\");\n\n        uint32 nCheckpoints = numCheckpoints[account];\n        if (nCheckpoints == 0) {\n            return 0;\n        }\n\n        // First check most recent balance\n        if (checkpoints[account][nCheckpoints - 1].fromBlock <= blockNumber) {\n            return checkpoints[account][nCheckpoints - 1].votes;\n        }\n\n        // Next check implicit zero balance\n        if (checkpoints[account][0].fromBlock > blockNumber) {\n            return 0;\n        }\n\n        uint32 lower = 0;\n        uint32 upper = nCheckpoints - 1;\n        while (upper > lower) {\n            uint32 center = upper - (upper - lower) / 2; // ceil, avoiding overflow\n            Checkpoint memory cp = checkpoints[account][center];\n            if (cp.fromBlock == blockNumber) {\n                return cp.votes;\n            } else if (cp.fromBlock < blockNumber) {\n                lower = center;\n            } else {\n                upper = center - 1;\n            }\n        }\n        return checkpoints[account][lower].votes;\n    }\n\n    function _delegate(address delegator, address delegatee) internal {\n        address currentDelegate = delegates[delegator];\n        uint256 delegatorBalance = balanceOf(delegator);\n        delegates[delegator] = delegatee;\n\n        emit DelegateChanged(delegator, currentDelegate, delegatee);\n\n        _moveDelegates(currentDelegate, delegatee, delegatorBalance);\n    }\n\n    function _moveDelegates(\n        address srcRep,\n        address dstRep,\n        uint256 amount\n    ) internal {\n        if (srcRep != dstRep && amount > 0) {\n            if (srcRep != address(0)) {\n                // decrease old representative\n                uint32 srcRepNum = numCheckpoints[srcRep];\n                uint256 srcRepOld = srcRepNum > 0 ? checkpoints[srcRep][srcRepNum - 1].votes : 0;\n                uint256 srcRepNew = srcRepOld.sub(amount);\n                _writeCheckpoint(srcRep, srcRepNum, srcRepOld, srcRepNew);\n            }\n\n            if (dstRep != address(0)) {\n                // increase new representative\n                uint32 dstRepNum = numCheckpoints[dstRep];\n                uint256 dstRepOld = dstRepNum > 0 ? checkpoints[dstRep][dstRepNum - 1].votes : 0;\n                uint256 dstRepNew = dstRepOld.add(amount);\n                _writeCheckpoint(dstRep, dstRepNum, dstRepOld, dstRepNew);\n            }\n        }\n    }\n\n    function _writeCheckpoint(\n        address delegatee,\n        uint32 nCheckpoints,\n        uint256 oldVotes,\n        uint256 newVotes\n    ) internal {\n        uint32 blockNumber =\n            safe32(block.number, \"VSP::_writeCheckpoint: block number exceeds 32 bits\");\n\n        if (nCheckpoints > 0 && checkpoints[delegatee][nCheckpoints - 1].fromBlock == blockNumber) {\n            checkpoints[delegatee][nCheckpoints - 1].votes = newVotes;\n        } else {\n            checkpoints[delegatee][nCheckpoints] = Checkpoint(blockNumber, newVotes);\n            numCheckpoints[delegatee] = nCheckpoints + 1;\n        }\n\n        emit DelegateVotesChanged(delegatee, oldVotes, newVotes);\n    }\n\n    function safe32(uint256 n, string memory errorMessage) internal pure returns (uint32) {\n        require(n < 2**32, errorMessage);\n        return uint32(n);\n    }\n\n    function getChainId() internal pure returns (uint256 chainId) {\n        assembly {\n            chainId := chainid()\n        }\n    }\n}\n"
    },
    "contracts/governor/VVSP.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"./PoolShareGovernanceToken.sol\";\nimport \"../interfaces/uniswap/IUniswapV2Router02.sol\";\nimport \"../../sol-address-list/contracts/interfaces/IAddressList.sol\";\n\ninterface IVSPStrategy {\n    function rebalance() external;\n}\n\n//solhint-disable no-empty-blocks, reason-string\ncontract VVSP is PoolShareGovernanceToken {\n    address internal constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n    IAddressList public immutable pools;\n\n    // Lock period, in seconds, is minimum required time between deposit and withdraw\n    uint256 public lockPeriod;\n\n    // user address to last deposit timestamp mapping\n    mapping(address => uint256) public depositTimestamp;\n\n    constructor(address _controller, address _token)\n        public\n        PoolShareGovernanceToken(\"vVSP pool\", \"vVSP\", _token, _controller)\n    {\n        pools = IAddressList(IController(_controller).pools());\n        lockPeriod = 1 days;\n    }\n\n    modifier onlyController() {\n        require(address(controller) == _msgSender(), \"Caller is not the controller\");\n        _;\n    }\n\n    function pause() external onlyController {\n        _pause();\n    }\n\n    function unpause() external onlyController {\n        _unpause();\n    }\n\n    function shutdown() external onlyController {\n        _shutdown();\n    }\n\n    function open() external onlyController {\n        _open();\n    }\n\n    /// @dev Approve strategy for given pool\n    function approveToken(address pool, address strategy) external onlyController {\n        require(pools.contains(pool), \"Not a pool\");\n        require(strategy == controller.strategy(address(this)), \"Not a strategy\");\n        IERC20(pool).safeApprove(strategy, MAX_UINT_VALUE);\n    }\n\n    /**\n     * @dev Controller will call this function when new strategy is added in pool.\n     * Approve strategy for all tokens\n     */\n    function approveToken() external onlyController {\n        _approve(MAX_UINT_VALUE);\n    }\n\n    /// @dev update deposit lock period, only controller can call this function.\n    function updateLockPeriod(uint256 _newLockPeriod) external onlyController {\n        lockPeriod = _newLockPeriod;\n    }\n\n    /**\n     * @dev Controller will call this function when strategy is removed from pool.\n     * Reset approval of all tokens\n     */\n    function resetApproval() external onlyController {\n        _approve(uint256(0));\n    }\n\n    function rebalance() external {\n        require(!stopEverything || (_msgSender() == address(controller)), \"Contract has shutdown\");\n        IVSPStrategy strategy = IVSPStrategy(controller.strategy(address(this)));\n        strategy.rebalance();\n    }\n\n    function sweepErc20(address _erc20) external {\n        require(\n            _erc20 != address(token) && _erc20 != address(this) && !controller.isPool(_erc20),\n            \"Not allowed to sweep\"\n        );\n        IUniswapV2Router02 uniswapRouter = IUniswapV2Router02(controller.uniswapRouter());\n        IERC20 erc20 = IERC20(_erc20);\n        uint256 amt = erc20.balanceOf(address(this));\n        erc20.safeApprove(address(uniswapRouter), 0);\n        erc20.safeApprove(address(uniswapRouter), amt);\n        address[] memory path;\n        if (address(_erc20) == WETH) {\n            path = new address[](2);\n            path[0] = address(_erc20);\n            path[1] = address(token);\n        } else {\n            path = new address[](3);\n            path[0] = address(_erc20);\n            path[1] = address(WETH);\n            path[2] = address(token);\n        }\n        uniswapRouter.swapExactTokensForTokens(amt, 1, path, address(this), now + 30);\n    }\n\n    function _afterBurning(uint256 amount) internal override {\n        token.safeTransfer(_msgSender(), amount);\n    }\n\n    function _beforeMinting(uint256 amount) internal override {\n        token.safeTransferFrom(_msgSender(), address(this), amount);\n    }\n\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal override {\n        if (from == address(0)) {\n            // Token being minted i.e. user is depositing VSP\n            // NOTE: here 'to' is same as 'msg.sender'\n            depositTimestamp[to] = block.timestamp;\n        } else {\n            // transfer, transferFrom or withdraw is called.\n            require(\n                block.timestamp >= depositTimestamp[from].add(lockPeriod),\n                \"Operation not allowed due to lock period\"\n            );\n        }\n        // Move vVSP delegation when mint, burn, transfer or transferFrom is called.\n        _moveDelegates(delegates[from], delegates[to], amount);\n    }\n\n    function _approve(uint256 approvalAmount) private {\n        address strategy = controller.strategy(address(this));\n        uint256 length = pools.length();\n        for (uint256 i = 0; i < length; i++) {\n            (address pool, ) = pools.at(i);\n            IERC20(pool).safeApprove(strategy, approvalAmount);\n        }\n    }\n}\n"
    },
    "contracts/pools/VDAI.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"./VTokenBase.sol\";\n\n//solhint-disable no-empty-blocks\ncontract VDAI is VTokenBase {\n    constructor(address _controller)\n        public\n        VTokenBase(\"vDAI Pool\", \"vDAI\", 0x6B175474E89094C44Da98b954EedeAC495271d0F, _controller)\n    {}\n}\n"
    },
    "contracts/test/Crv3PoolMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"../strategies/Crv3PoolMgr.sol\";\n\ncontract Crv3PoolMock is Crv3PoolMgr {\n    /* solhint-disable */\n    constructor() public Crv3PoolMgr() {}\n\n    /* solhint-enable */\n\n    function depositToCrvPool(\n        uint256 _daiAmount,\n        uint256 _usdcAmount,\n        uint256 _usdtAmount\n    ) external {\n        _depositToCrvPool(_daiAmount, _usdcAmount, _usdtAmount);\n    }\n\n    function depositDaiToCrvPool(uint256 _daiAmount, bool _stake) external {\n        _depositDaiToCrvPool(_daiAmount, _stake);\n    }\n\n    function withdrawAsFromCrvPool(\n        uint256 _lpAmount,\n        uint256 _minDai,\n        uint256 i\n    ) external {\n        _withdrawAsFromCrvPool(_lpAmount, _minDai, i);\n    }\n\n    function withdrawAllAs(uint256 i) external {\n        _withdrawAllAs(i);\n    }\n\n    function stakeAllLpToGauge() external {\n        _stakeAllLpToGauge();\n    }\n\n    function unstakeAllLpFromGauge() external {\n        _unstakeAllLpFromGauge();\n    }\n\n    function unstakeLpFromGauge(uint256 _amount) external {\n        _unstakeLpFromGauge(_amount);\n    }\n\n    function claimCrv() external {\n        _claimCrv();\n    }\n\n    function setCheckpoint() external {\n        _setCheckpoint();\n    }\n\n    // if using this contract on its own.\n    function approveLpForGauge() external {\n        IERC20(crvLp).safeApprove(crvGauge, 0);\n        IERC20(crvLp).safeApprove(crvGauge, type(uint256).max);\n    }\n\n    // if using this contract on its own.\n    function approveTokenForPool(address _token) external {\n        IERC20(_token).safeApprove(crvPool, 0);\n        IERC20(_token).safeApprove(crvPool, type(uint256).max);\n    }\n}\n"
    },
    "contracts/strategies/Crv3PoolStrategyDAI.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"./Crv3PoolStrategy.sol\";\n\n//solhint-disable no-empty-blocks\ncontract Crv3PoolStrategyDAI is Crv3PoolStrategy {\n    string public constant NAME = \"Strategy-Curve-3pool-DAI\";\n    string public constant VERSION = \"1.0.0\";\n\n    constructor(address _controller, address _pool)\n        public\n        Crv3PoolStrategy(_controller, _pool, 0)\n    {}\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}